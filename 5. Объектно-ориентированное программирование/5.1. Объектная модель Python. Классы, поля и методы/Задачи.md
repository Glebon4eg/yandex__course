## Классная точка

<details>
  <summary>Условие</summary>
  Объектно-ориентированное программирование — популярная парадигма в современном мире. Это вполне очевидно, ведь любой объект реального мира мы теперь можем представить в виде цифрового набора полей и методов. Давайте приступим к проектированию классов.

  Разработайте класс Point, который при инициализации принимает координаты точки на декартовой плоскости и сохраняет их в поля x и y соответственно.
  
  ### Примечание
  Ваше решение должно содержать только классы и функции. 
  В решении не должно быть вызовов инициализации требуемых классов.


</details>

<details>
  <summary>Решение</summary>

  ```python
  class Point:
      def __init__(self, x, y):
          self.x = x
          self.y = y
  ```

</details>

## Классная точка 2.0

<details>
  <summary>Условие</summary>
  Давайте расширим функционал класса, написанного в прошлой задаче.

  Реализуйте методы:
  
  - move, который перемещает точку на заданное расстояние по осям x и y;
  - length, который определяет до переданной точки расстояние, округлённое до сотых.
  
  ### Примечание
  Ваше решение должно содержать только классы и функции. 
  В решении не должно быть вызовов инициализации требуемых классов.


</details>

<details>
  <summary>Решение</summary>

  ```python
  class Point:
      def __init__(self, x, y):
          self.x = x
          self.y = y
  
      def move(self, move_x, move_y):
          self.x += move_x
          self.y += move_y
  
      def length(self, point_to_calculate):
          distance = (point_to_calculate.x - self.x) ** 2 + (point_to_calculate.y - self.y) ** 2
          distance = round(distance ** 0.5, 2)
          return distance
  ```

</details>

## Не нажимай красную кнопку!

<details>
  <summary>Условие</summary>
  Если написать предупреждение «Не нажимай красную кнопку!», то её сразу безумно хочется нажать.

  Напишите класс RedButton, который описывает красную кнопку.
  
  Класс должен реализовывать методы:
  
  - click() — эмулирует нажатие кнопки, выводит сообщение "Тревога!";
  - count() — возвращает количество раз, которое была нажата кнопка.
  
  ### Примечание
  Ваше решение должно содержать только классы и функции. 
  В решении не должно быть вызовов инициализации требуемых классов.


</details>

<details>
  <summary>Решение</summary>

  ```python
  class RedButton:
      def __init__(self):
          self.click_counts = 0
  
      def click(self):
          self.click_counts += 1
          return print("Тревога!")
  
      def count(self):
          return self.click_counts

  ```

</details>

## Работа не волк

<details>
  <summary>Условие</summary>
  Рассмотрим объект «Программист», который задаётся именем, должностью и количеством отработанных часов. Каждая должность имеет собственный оклад (заработную плату за час работы). В нашей импровизированной компании существуют 3 должности:

  - Junior — с окладом 10 тугриков в час;
  - Middle — с окладом 15 тугриков в час;
  - Senior — с окладом 20 тугриков в час по умолчанию и +1 тугрик за каждое новое повышение.
  
  Напишите класс Programmer, который инициализируется именем и должностью (отработка у нового работника равна нулю). Класс реализует следующие методы:
  
  - work(time) — отмечает новую отработку в количестве часов time;
  - rise() — повышает программиста;
  - info() — возвращает строку для бухгалтерии в формате: <имя> <количество отработанных часов>ч. <накопленная зарплата>тгр.
  
  ### Примечание
  Ваше решение должно содержать только классы и функции. 
  В решении не должно быть вызовов инициализации требуемых классов.


</details>

<details>
  <summary>Решение</summary>

  ```python
  class Programmer:
      def __init__(self, name_of_worker, position):
          self.name = name_of_worker
          if position == "Junior":
              self.pos_payment = 10
          elif position == "Middle":
              self.pos_payment = 15
          else:
              self.pos_payment = 20
          self.time = 0
          self.worked_time = 0
          self.payday = 0
  
      def work(self, time_of_work):
          self.time += time_of_work
          self.payday += time_of_work * self.pos_payment
  
      def rise(self):
          if self.pos_payment == 10:
              self.pos_payment = 15
          elif self.pos_payment == 15:
              self.pos_payment = 20
          else:
              self.pos_payment += 1
  
      def info(self):
          return f'{self.name} {self.time}ч. {self.payday}тгр.'
  ```

</details>

## Классный прямоугольник

<details>
  <summary>Условие</summary>
  Давайте перейдём к более сложным геометрическим фигурам.

  Разработайте класс Rectangle.
  
  При инициализации класс принимает два кортежа рациональных координат противоположных углов прямоугольника (со сторонами параллельными осям координат).
  
  Класс должен реализовывать методы:
  
  - perimeter — возвращает периметр прямоугольника;
  - area — возвращает площадь прямоугольника.
  
  Все результаты вычислений нужно округлить до сотых.
  
  ### Примечание
  Ваше решение должно содержать только классы и функции. 
  В решении не должно быть вызовов инициализации требуемых классов.


</details>

<details>
  <summary>Решение</summary>

  ```python
  class Rectangle:

      def __init__(self, first_angle, second_angle):
          self.x1 = first_angle[0]
          self.y1 = first_angle[1]
          self.x2 = second_angle[0]
          self.y2 = first_angle[1]
          self.x3 = second_angle[0]
          self.y3 = second_angle[1]
          self.x4 = first_angle[0]
          self.y4 = second_angle[1]
          self.a = abs(first_angle[0] - second_angle[0])
          self.b = abs(first_angle[1] - second_angle[1])
  
      def perimeter(self):
          return round((self.a + self.b) * 2, 2)
  
      def area(self):
          return round(self.a * self.b, 2)
  ```

</details>

## Классный прямоугольник 2.0

<details>
  <summary>Условие</summary>
  Расширим функционал класса написанного вами в предыдущей задаче.

  Реализуйте методы:
  
  - get_pos() — возвращает координаты верхнего левого угла в виде кортежа;
  - get_size() — возвращает размеры в виде кортежа;
  - move(dx, dy) — изменяет положение на заданные значения;
  - resize(width, height) — изменяет размер (положение верхнего левого угла остаётся неизменным).
  
  ### Примечание
  Ваше решение должно содержать только классы и функции. 
  В решении не должно быть вызовов инициализации требуемых классов.  
  Все результаты вычислений нужно округлить до сотых.


</details>

<details>
  <summary>Решение</summary>

  ```python
  class Rectangle:
      def __init__(self, first_angle, second_angle):
          self.left_down = [min(first_angle[0], second_angle[0]),
                            min(first_angle[1], second_angle[1])]
          self.up_right = [max(first_angle[0], second_angle[0]),
                           max(first_angle[1], second_angle[1])]
  
      def perimeter(self):
          return round((self.up_right[0] - self.left_down[0]) * 2 +
                       (self.up_right[1] - self.left_down[1]) * 2, 2)
  
      def area(self):
          return round((self.up_right[0] - self.left_down[0]) *
                       (self.up_right[1] - self.left_down[1]), 2)
  
      def get_pos(self):
          return round(self.left_down[0], 2), round(self.up_right[1], 2)
  
      def get_size(self):
          return round(self.up_right[0] - self.left_down[0], 2), \
              round(self.up_right[1] - self.left_down[1], 2)
  
      def move(self, dx, dy):
          self.left_down[0] += dx
          self.left_down[1] += dy
          self.up_right[0] += dx
          self.up_right[1] += dy
  
      def resize(self, width, height):
          self.up_right[0] = self.left_down[0] + width
          self.left_down[1] = self.up_right[1] - height
  ```

</details>

## Классный прямоугольник 3.0

<details>
  <summary>Условие</summary>
  Необходимо ещё немного доработать предыдущую задачу.

  Разработайте методы:
  
  - turn() — поворачивает прямоугольник на 90&deg; по часовой стрелке вокруг его центра;
  - scale(factor) — изменяет размер в указанное количество раз, тоже относительно центра.
  Все вычисления производить с округлением до сотых.
  
  ### Примечание
  Ваше решение должно содержать только классы и функции. 
  В решении не должно быть вызовов инициализации требуемых классов.


</details>

<details>
  <summary>Решение</summary>

  ```python
  #Ломается на третьем тесте
  class Rectangle:
      def __init__(self, first_angle, second_angle):
          self.left_down = [round(min(first_angle[0], second_angle[0]), 2),
                            round(min(first_angle[1], second_angle[1]), 2)]
          self.right_up = [round(max(first_angle[0], second_angle[0]), 2),
                           round(max(first_angle[1], second_angle[1]), 2)]
  
      def perimeter(self):
          return round((self.right_up[0] - self.left_down[0]) * 2 +
                       (self.right_up[1] - self.left_down[1]) * 2, 2)
  
      def area(self):
          return round((self.right_up[0] - self.left_down[0]) *
                       (self.right_up[1] - self.left_down[1]), 2)
  
      def get_pos(self):
          return round(self.left_down[0], 2), round(self.right_up[1], 2)
  
      def get_size(self):
          return round(self.right_up[0] - self.left_down[0], 2), \
              round(self.right_up[1] - self.left_down[1], 2)
  
      def move(self, dx, dy):
          self.left_down[0] += dx
          self.left_down[1] += dy
          self.right_up[0] += dx
          self.right_up[1] += dy
  
      def resize(self, width, height):
          self.right_up[0] = self.left_down[0] + width
          self.left_down[1] = self.right_up[1] - height
  
      def scale(self, factor):
          center = [(self.right_up[0] + self.left_down[0]) / 2,
                    (self.right_up[1] + self.left_down[1]) / 2]
          sizes_half = [x / 2 for x in self.get_size()]
          self.right_up = [round(center[i] + sizes_half[i] * factor, 2) for i in range(2)]
          self.left_down = [round(center[i] - sizes_half[i] * factor, 2) for i in range(2)]
  
      def turn(self):
          temp = [self.right_up[0], self.right_up[1]]
          self.right_up = [temp[1], temp[0]]
          temp = [self.left_down[0], self.left_down[1]]
          self.left_down = [temp[1], temp[0]]
  ```

</details>

## Шашки

<details>
  <summary>Условие</summary>
  Шашки очень занимательная игра, которую достаточно легко моделировать.

  Правила подразумевают наличие двух классов: игральная доска и шашка. Однако мы немного упростим себе задачу и вместо шашки будем манипулировать клетками, которые могут находиться в трех состояниях: пустая, белая шашка и чёрная шашка.
  
  Разработайте два класса: Checkers и Cell.
  
  Объекты класса Checkers при инициализации строят игральную доску со стандартным распределением клеток и должны обладать методами:
  
  - move(f, t) — перемещает шашку из позиции f в позицию t;
  - get_cell(p) — возвращает объект «клетка» в позиции p.
  
  Объекты класса Cell при инициализации принимают одно из трех состояний: W — белая шашка, B — чёрная шашка, X — пустая клетка, а также обладают методом status() возвращающим заложенное в ней состояние.
  
  Координаты клеток описываются строками вида PQ, где:
  
  - P — столбец игральной доски, одна из заглавных латинских букв: ABCDEFGH;
  - Q — строка игральной доски, одна из цифр: 12345678.
  
  Будем считать, что пользователь всегда ходит правильно и контролировать возможность хода не требуется.
  
  ### Примечание
  Ваше решение должно содержать только классы и функции. 
  В решении не должно быть вызовов инициализации требуемых классов.


</details>

<details>
  <summary>Решение</summary>

  ```python
  class Cell:
      def __init__(self, cell_item='X'):
          self.state = cell_item
  
      def status(self):
          return self.state
  
      def remove_check(self):
          check = self.status()
          self.state = 'X'
          return check
  
      def set_check(self, check):
          old_check = self.status()
          self.state = check
          return old_check
  
  
  class Checkers:
      def __init__(self):
          self.cells = dict()
          checker_board = ('XBXBXBXB' + 'BXBXBXBX' + 'XBXBXBXB' + 'XXXXXXXX' + 
                           'XXXXXXXX' + 'WXWXWXWX' + 'XWXWXWXW' + 'WXWXWXWX')
  
          i = 0
          for row in '87654321':
              for col in 'ABCDEFGH':
                  self.cells[col + row] = Cell(cell_item=checker_board[i])
                  i += 1
  
      def get_cell(self, cell):
          return self.cells[cell]
  
      def move(self, where_from, where_to):
          check = self.cells[where_from].remove_check()
          return self.cells[where_to].set_check(check)
  ```

</details>

## Очередь

<details>
  <summary>Условие</summary>
  В программировании существует потребность не только в изученных нами коллекциях. Одна из таких очередь. Она реализует подход к хранению данных по принципу «Первый вошёл – первый ушел».

  Реализуйте класс Queue, который не имеет параметров инициализации, но поддерживает методы:
  
  - push(item) — добавить элемент в конец очереди;
  - pop() — «вытащить» первый элемент из очереди;
  - is_empty() — проверят очередь на пустоту.
  
  ### Примечание
  Ваше решение должно содержать только классы и функции. 
  В решении не должно быть вызовов инициализации требуемых классов.


</details>

<details>
  <summary>Решение</summary>

  ```python
  class Queue:
      queue = []
  
      def push(self, item):
          self.queue.append(item)
  
      def pop(self):
          return self.queue.pop(0)
  
      def is_empty(self):
          return self.queue == []
  ```

</details>

## Стек

<details>
  <summary>Условие</summary>
  Ещё одной полезной коллекцией является стек реализующий принцип «Последний пришёл – первый ушёл». Его часто представляют как стопку карт или магазин пистолета, где приходящие элементы закрывают выход уже находящимся в коллекции.

  Реализуйте класс Stack, который не имеет параметров инициализации, но поддерживает методы:
  
  - push(item) — добавить элемент в конец стека;
  - pop() — «вытащить» первый элемент из стека;
  - is_empty() — проверяет стек на пустоту.
  
  ### Примечание
  Ваше решение должно содержать только классы и функции. 
  В решении не должно быть вызовов инициализации требуемых классов.


</details>

<details>
  <summary>Решение</summary>

  ```python
  class Stack:
      def __init__(self):
          self.stack = []
  
      def push(self, data):
          self.stack.append(data)
  
      def pop(self):
          return self.stack.pop()
  
      def is_empty(self):
          return self.stack == []
  ```

</details>
