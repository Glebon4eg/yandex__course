## Обработка ошибок

<details>
  <summary>Условие</summary>
  Вашему решению будет предоставлена функция func, которая не имеет параметров и результата. Однако во время её исполнения может произойти одна из ошибок: ValueError, TypeError или SystemError.

  Вызовите её, обработайте ошибку и выведите её название. Если ошибка не произойдёт, выведите сообщение "No Exceptions".


</details>

<details>
  <summary>Решение</summary>

  ```python
  try:
      func()
  except ValueError:
      print('ValueError')
  except TypeError:
      print('TypeError')
  except SystemError:
      print('SystemError')
  except Exception as err:
      print('Unexpected error: {err}')
  else:
      print('No Exceptions')
  ```

</details>

## Ломать — не строить

<details>
  <summary>Условие</summary>
  Давайте немного поиграем в «багоюзеров».

  Вашему решению будет предоставлена функция func, которая принимает два позиционных параметра и производит с ними некую математическую операцию.
  
  Предложите вызов функции, который гарантированно породит ошибку внутри функции.
  
  ### Примечание
  Если ошибка произойдёт внутри функции, то она будет перехвачена и обработана. 
  Если же она произойдет в вашем коде, то программа будет завершена с ошибкой.


</details>

<details>
  <summary>Решение</summary>

  ```python
  a = 'str' 
  b = (3, 5)
  
  func(a, b)
  ```

</details>

## Ломать — не строить 2

<details>
  <summary>Условие</summary>
  Вашему решению будет предоставлена функция func, которая на этот раз принимает неограниченное число позиционных параметров и производит с ними некую операцию приведения типа.

  Предложите вызов функции, который гарантированно породит ошибку внутри функции.
  
  ### Примечание
  Если ошибка произойдёт внутри функции, то она будет перехвачена и обработана. 
  Если же она произойдет в вашем коде, то программа будет завершена с ошибкой.


</details>

<details>
  <summary>Решение</summary>

  ```python
  class MyClass:

      def __repr__(self):
          raise Exception
  
  
  a = MyClass()
  func(a)
  ```

</details>

## Контроль параметров

<details>
  <summary>Условие</summary>
  Напишите функцию only_positive_even_sum, которая принимает два параметра и возвращает их сумму.

  Если один из параметров не является целым числом, то следует вызвать исключение TypeError. 
  Если один из параметров не является положительным чётным числом, то следует вызвать исключение ValueError.
  
  ### Примечание
  Ваше решение должно содержать только функции. 
  В решении не должно быть вызовов требуемых функций.


</details>

<details>
  <summary>Решение</summary>

  ```python
  def only_positive_even_sum(*args):
      for item in args:
          if not isinstance(item, int):
              raise TypeError
      for item in args:
          if item <= 0 or item % 2 != 0:
              raise ValueError
      return sum(args)
  ```

</details>

## Слияние с проверкой

<details>
  <summary>Условие</summary>
  Когда-то вы уже писали функцию merge, которая производит слияние двух отсортированных кортежей.

  Давай-те её немного переработаем.
  
  Введём систему проверок:
  
  - если один из параметров не является итерируемым объектом, то вызовите исключение StopIteration;
  - если значения входных параметров содержат «неоднородные» данные, то вызовите исключение TypeError;
  - если один из параметров не отсортирован, то вызовите исключение ValueError.
  
  Проверки следует проводить в указанном порядке.
  
  Если параметры прошли все проверки, верните итерируемый объект, являющийся слиянием двух переданных.
  
  ### Примечание
  В решении не должно быть вызовов требуемых функций.


</details>

<details>
  <summary>Решение</summary>

  ```python
  def check_queue_iterated(*queues):
      for queue in queues:
          try:
              iter(queue)
          except TypeError:
              raise StopIteration
  
  
  def check_queue_same_type(*queues):
      all_data = []
      for queue in queues:
          all_data.extend(list(queue))
      for data in all_data:
          if type(data) is not type(all_data[0]):
              raise TypeError
  
  
  def check_queue_sorted(*queues):
      for queue in queues:
          if list(queue) != sorted(queue):
              raise ValueError
      return True
  
  
  def merge(first_tuple, second_tuple):
      check_queue_iterated(first_tuple, second_tuple)
      check_queue_same_type(first_tuple, second_tuple)
      check_queue_sorted(first_tuple, second_tuple)
      merged_tuple = list()
      len_first = len(first_tuple)
      len_second = len(second_tuple)
      count_first = 0
      count_second = 0
      while (count_first < len_first) and (count_second < len_second):
          a = first_tuple[count_first]
          b = second_tuple[count_second]
          if min(a, b) == a:
              merged_tuple.append(a)
              count_first += 1
          elif min(a, b) == b:
              merged_tuple.append(b)
              count_second += 1
      if count_first == len_first:
          for i in range(count_second, len_second):
              merged_tuple.append(second_tuple[i])
      elif count_second == len_second:
          for i in range(count_first, len_first):
              merged_tuple.append(first_tuple[i])
      return merged_tuple
  ```

</details>

## Корень зла 2

<details>
  <summary>Условие</summary>
  В одной из первых лекций вы уже решали задачу о поиске корней уравнения. Давайте модернизируем её.

  Напишите функцию find_roots, принимающую три параметра: коэффициенты уравнения и возвращающую его корни в виде кортежа из двух значений.
  
  Так же создайте два собственных исключения NoSolutionsError и InfiniteSolutionsError, которые будут вызваны в случае отсутствия и бесконечного количества решений уравнения соответственно.
  
  Если переданные коэффициенты не являются рациональными числами, вызовите исключение TypeError.
  
  ### Примечание
  В решении не должно быть вызовов требуемых функций.


</details>

<details>
  <summary>Решение</summary>

  ```python
  class InfiniteSolutionsError(Exception):
      pass
  
  
  class NoSolutionsError(Exception):
      pass
  
  
  def find_roots(a, b, c):
  
      for num in (a, b, c):
          if not isinstance(num, (int, float)):
              raise TypeError
  
      if a == b == c == 0:
          raise InfiniteSolutionsError
      elif a == 0 and b != 0 and c != 0:
          roots = (-(c / b), -(c / b))
      elif a == b == 0:
          raise NoSolutionsError
      elif a == c == 0:
          roots = (0, 0)
      else:
          disc = (b ** 2) - (4 * a * c)
          if disc == 0:
              roots = ((-b) / (2 * a), (-b) / (2 * a))
          elif disc > 0:
              x1 = (-b - (disc ** 0.5)) / (2 * a)
              x2 = (-b + (disc ** 0.5)) / (2 * a)
              roots = tuple(sorted([x1, x2]))
          else:
              raise NoSolutionsError
      return roots
  ```

</details>

## Валидация имени

<details>
  <summary>Условие</summary>
  При регистрации в различных сервисах пользователи вводят большое количество информации. Правильное заполнение полей — важная часть работы программы, поэтому формы снабжают системами валидации данных.

  Напишите функцию name_validation, которая принимает один позиционный аргумент — фамилию или имя.
  
  Если параметр не является строкой, то вызовите исключение TypeError.
  
  А также разработайте собственные ошибки:
  
  - CyrillicError — вызывается, если значение не состоит только из кириллических букв;
  - CapitalError — вызывается, если значение не начинается с заглавной буквы или найдена заглавная буква не в начале значения.
  
  Обработка ошибок должна происходить в порядке, указанном в задании.
  
  В случае успешного выполнения, функция должна вернуть переданный параметр без изменений.
  
  ### Примечание
  В решении не должно быть вызовов требуемых функций.


</details>

<details>
  <summary>Решение</summary>

  ```python
  class CyrillicError(Exception):
      pass
  
  
  class CapitalError(Exception):
      pass
  
  
  def name_validation(name):
      valid_cyrillic_chars = 'абвгдеёжзийклмнопрстуфхцчшщъыьэюя'
      if not isinstance(name, str):
          raise TypeError
      for letter in name:
          if letter.lower() not in valid_cyrillic_chars:
              raise CyrillicError
      if not name.istitle():
          raise CapitalError
      return name

  ```

</details>

## Валидация имени пользователя

<details>
  <summary>Условие</summary>
  Продолжим реализацию системы валидации.

  Напишите функцию username_validation, которая принимает один позиционный аргумент — имя пользователя:
  
  Если параметр не является строкой, то вызовите исключение TypeError.
  
  А также разработайте собственные ошибки:
  
  - BadCharacterError — вызывается, если значение состоит не только из латинских букв, цифр и символа нижнего подчёркивания;
  - StartsWithDigitError — вызывается, если значение начинается с цифры.
  
  Обработка ошибок должна происходить в порядке, указанном в задании.
  
  В случае успешного выполнения, функция должна вернуть переданный параметр без изменений.
  
  ### Примечание
  В решении не должно быть вызовов требуемых функций.


</details>

<details>
  <summary>Решение</summary>

  ```python
  class CyrillicError(Exception):
      pass
  
  
  class CapitalError(Exception):
      pass
  
  
  class BadCharacterError(Exception):
      pass
  
  
  class StartsWithDigitError(Exception):
      pass
  
  
  def username_validation(username):
      valid_username_chars = 'abcdefghijklmnopqrstuvwxyz_0123456789'
      if not isinstance(username, str):
          raise TypeError
      for letter in username:
          if letter.lower() not in valid_username_chars:
              raise BadCharacterError
      if username[0].isdigit():
          raise StartsWithDigitError
      return username
  ```

</details>

## Валидация пользователя

<details>
  <summary>Условие</summary>
  Используйте две предыдущих функции валидации и напишите функцию user_validation, которая принимает именованныеаргументы:

  - last_name — фамилия;
  - first_name — имя;
  - username — имя пользователя.
  
  Если функции был передан неизвестный параметр или не передан один из обязательных, то вызовите исключение KeyError.
  
  Если один из параметров не является строкой, то вызовите исключение TypeError.
  
  Обработка данных должна происходить в порядке: фамилия, имя, имя пользователя.
  
  Если поле заполнено верно, функция возвращает словарь с данными пользователя.
  
  ### Примечание
  В решении не должно быть вызовов требуемых функций.


</details>

<details>
  <summary>Решение</summary>

  ```python
  class CyrillicError(Exception):
      pass
  
  
  class CapitalError(Exception):
      pass
  
  
  class BadCharacterError(Exception):
      pass
  
  
  class StartsWithDigitError(Exception):
      pass
  
  
  def name_validation(name):
      valid_cyrillic_chars = 'абвгдеёжзийклмнопрстуфхцчшщъыьэюя'
      if not isinstance(name, str):
          raise TypeError
      for letter in name:
          if letter.lower() not in valid_cyrillic_chars:
              raise CyrillicError
      if not name.istitle():
          raise CapitalError
      return name
  
  
  def username_validation(username):
      valid_username_chars = 'abcdefghijklmnopqrstuvwxyz_0123456789'
      if not isinstance(username, str):
          raise TypeError
      for letter in username:
          if letter.lower() not in valid_username_chars:
              raise BadCharacterError
      if username[0].isdigit():
          raise StartsWithDigitError
      return username
  
  
  def user_validation(**kwargs):
      all_data = kwargs
      last_name = kwargs.get("last_name")
      first_name = kwargs.get("first_name")
      username = kwargs.get("username")
      if last_name is None:
          raise KeyError
      if first_name is None:
          raise KeyError
      if username is None:
          raise KeyError
      if len(all_data) > 3:
          raise KeyError
      name_validation(last_name)
      name_validation(first_name)
      username_validation(username)
      return kwargs
  ```

</details>

## Валидация пароля

<details>
  <summary>Условие</summary>
  После того как пользователь ввёл свои данные в требуемом формате, можно позаботиться и о пароле.

  Напишите функцию password_validation, которая принимает один позиционный параметр — пароль, и следующие именованные параметры:
  
  - min_length — минимальная длина пароля, по умолчанию 8;
  - possible_chars — строка символов, которые могут быть в пароле, по умолчанию латинские буквы и цифры;
  - at_least_one — функция возвращающая логическое значение, по умолчанию str.isdigit.
  
  Если переданный позиционный параметр не является строкой, вызовите исключение TypeError.
  
  А так же реализуйте собственные исключения:
  
  - MinLengthError — вызывается, если пароль меньше заданной длины;
  - PossibleCharError — вызывается, если в пароле используется недопустимый символ;
  - NeedCharError — вызывается, если в пароле не найдено ни одного обязательного символа.
  
  Проверка условий должна происходить в порядке указанном в задании.
  
  Так как, хороший разработчик никогда не хранит пароли в открытом виде, функция, в случае успешного завершения, возвращает хеш пароля. Для этого воспользуйтесь функцией sha256 из пакета hashlib и верните его шестнадцатеричное представление.
  
  ### Примечание
  В решении не должно быть вызовов требуемых функций.


</details>

<details>
  <summary>Решение</summary>

  ```python
  import hashlib

  
  class MinLengthError(Exception):
      pass
  
  
  class PossibleCharError(Exception):
      pass
  
  
  class NeedCharError(Exception):
      pass
  
  
  def password_validation(password, min_length=8,
                          possible_chars="ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789",
                          at_least_one=str.isdigit):
      if not isinstance(password, str):
          raise TypeError
      if len(password) < min_length:
          raise MinLengthError
      for letter in password:
          if letter not in possible_chars:
              raise PossibleCharError
      if not any(map(at_least_one, password)):
          raise NeedCharError
      return hashlib.sha256(bytearray(password, 'UTF-8')).hexdigest()
  ```

</details>
