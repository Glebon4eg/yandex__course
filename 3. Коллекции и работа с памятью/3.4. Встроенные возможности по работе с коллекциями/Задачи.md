## Автоматизация списка

<details>
  <summary>Условие</summary>
  Многим весьма часто приходится вести списки продуктов, дел и так далее.

  Напишите программу, которая преобразует введённую строку в нумерованный список.
  
  ### Формат ввода
  Вводится одна строка.
  
  ### Формат вывода
  Требуется вывести нумерованный список, составленный из её слов.


</details>

<details>
  <summary>Решение</summary>

  ```python
  for index, value in enumerate(text := input().split(), 1):
      print(f'{index}. {value}')
  ```

</details>

## Сборы на прогулку

<details>
  <summary>Условие</summary>
  Воспитатель в детском саду устал тратить время, чтобы построить детей по парам.

  Он договорился с детьми, чтобы те делились на две, по возможности равные, группы.
  
  Напишите программу, которая по списку двух шеренг составляет пары детей.
  
  ### Формат ввода
  Вводится две строки с именами детей, записанными через запятую и пробел.
  
  ### Формат вывода
  Требуется вывести список пар, которые можно составить, если последовательно брать из каждой шеренги по одному ребёнку.
  Имена в парах выводить через дефис окружённый пробелами.
  
  ### Примечание
  В одной из групп может быть на одного ребенка больше, чем в другой.
  Этот ребёнок при формировании пар не учитывается и идёт в паре с воспитателем.


</details>

<details>
  <summary>Решение</summary>

  ```python
  pairs = list(zip(text := input().split(","), text_2 := input().split(",")))
  for value in pairs:
      print(f'{value[0]} - {value[1].lstrip(" ")}'.lstrip(" "))

  ```

</details>

## Рациональная считалочка

<details>
  <summary>Условие</summary>
  Напишите программу, которая производит счёт по заданным параметрам.

  ### Формат ввода
  В одну строку через пробел вводятся 3 рациональных числа — начало счета, конец и шаг.
  
  ### Формат вывода
  Последовательность чисел с заданными параметрами.


</details>

<details>
  <summary>Решение</summary>

  ```python
  from itertools import count

  start, end, step = [float(i) for i in input().split()]
  for value in count(start, step):
      if value <= end:
          print(f'{value:.2f}')
      else:
          break

  ```

</details>

## Словарная ёлка

<details>
  <summary>Условие</summary>
  Напишите программу, которая преобразует строку слов в ёлку как показано в примере.

  ### Формат ввода
  В одну строку через пробел вводятся слова разделенные пробелом.
  
  ### Формат вывода
  Несколько строк. В каждой следующей строке на одно слово больше.
  
  ### Примечание
  accumulate «складывает» не только числа.


</details>

<details>
  <summary>Решение</summary>

  ```python
  from itertools import accumulate
  text = input().replace(" ", " ,").split(",")
  for value in accumulate(text):
      print(f'{value}')
  ```

</details>

## Список покупок

<details>
  <summary>Условие</summary>
  Поход в магазин часто вызывает проблемы. Если не подготовить список, можно уйти в магазин за хлебом, а вернуться с десятком пакетов. Напишите программу, которая собирает пожелания семьи (мамы, папы и дочки) в единый список.

  ### Формат ввода
  В трёх строках записаны желаемые продукты (через запятую и пробел).
  
  ### Формат вывода
  Отсортированный по алфавиту список продуктов с нумерацией.
  
  ### Примечание
  Помните, что итераторы можно применять к другим итераторам.


</details>

<details>
  <summary>Решение</summary>

  ```python
  text = input().split(", ")
  for i in range(2):
      for word in input().split(", "):
          text.append(word)
  
  for index, value in enumerate(sorted(text), 1):
      print(f'{index}. {value}')
  ```

</details>

## Колода карт

<details>
  <summary>Условие</summary>
  Сгенерируйте и выведите на экран колоду игральных карт без одной из мастей: три масти от двойки до туза. Масть, которая должна быть выброшена, вводится пользователем. Используйте итератор product для того, чтобы скомбинировать масти и номиналы.

  Названия карт должны быть в формате «номинал масть». Например: «2 пик», «10 треф», «валет бубен», «дама червей».
  Порядок мастей имеет значение.
  
  ### Формат ввода
  Название масти, которая должна быть выброшена, передаётся в том же падеже, в котором она выводится на экран: «пик», «треф», «бубен» и «червей».
  
  ### Формат вывода
  Список карт в колоде по увеличению номинала, затем масти (как в преферансе).


</details>

<details>
  <summary>Решение</summary>

  ```python
  from itertools import product

  cards = [2, 3, 4, 5, 6, 7, 8, 9, 10, "валет", "дама", "король", "туз"]
  masti = ["пик", "треф", "бубен", "червей"]
  masti.pop(masti.index(text := input()))
  for value in list(product(cards, masti)):
      print(f'{value[0]} {value[1]}')
  ```

</details>

## Игровая сетка

<details>
  <summary>Условие</summary>
  Ребята в классе решили устроить чемпионат по шашкам. К сожалению, количество учеников не является степенью двойки и поэтому классическую турнирную сетку создать сложно. Для выявления фаворитов ребята договорились сыграть по принципу «каждый с каждым». Продумайте программу, которая составляет список необходимых игр.

  ### Формат ввода
  В первой строке записано число учеников (N). 
  В каждой из последующих N строк записано одно имя.
  
  ### Формат вывода
  Список игр в формате:
  <Игрок 1> - <Игрок 2>
  
  Порядок игр не имеет значения.


</details>

<details>
  <summary>Решение</summary>

  ```python
  from itertools import combinations

  text = list(input() for i in range(int(input())))
  for value in list(combinations(text, 2)):
      print(f'{value[0]} - {value[1]}')

  ```

</details>

## Меню питания 2.0

<details>
  <summary>Условие</summary>
  В детском саду ежедневно подают новую кашу на завтрак.

  Напишите программу, которая строит расписание каш на ближайшие дни.
  
  ### Формат ввода
  Вводится натуральное число M — количество каш в меню. В каждой из последующих M строк записано одно название каши. В конце передается натуральное число N — количество дней.
  
  ### Формат вывода
  Вывести список каш в порядке подачи.
  
  ### Примечание
  Советуем изучить документацию на функцию itertools.islice, которая реализует срезы на основе итераторов.


</details>

<details>
  <summary>Решение</summary>

  ```python
  from itertools import islice

  n = int(input())
  text = list(input() for i in range(n))
  m = int(input())
  for i in range(m // n + 1):
      for j in range(n):
          text.append(text[j])
  for word in list(islice(text, None, m)):
      print(word)
  ```

</details>

## Таблица умножения 3.0

<details>
  <summary>Условие</summary>
  Местная фабрика канцелярских товаров заказала программу, которая генерирует таблицы умножения. 
  Давайте поможем производителю.
  
  ### Формат ввода
  Вводится одно натуральное число — требуемый размер таблицы.
  
  ### Формат вывода
  Таблица умножения заданного размера.
  
  ### Примечание
  itertools.product отличный способ, чтобы избавиться от вложенных циклов.


</details>

<details>
  <summary>Решение</summary>

  ```python
  from itertools import product, islice

  size = int(input())
  
  nums = range(1, size + 1)
  
  table = [x * y for x, y in product(nums, repeat=2)]
  
  for row in range(size):
      print(*islice(table, row * size, (row + 1) * size))
  ```

</details>

## Мы делили апельсин 2.0

<details>
  <summary>Условие</summary>
  Аня, Боря и Вова решили съесть апельсин. 
  Подскажите ребятам, как им его разделить.
  
  Разработайте программу, которая выводит все возможные способы разделки апельсина.
  
  ### Формат ввода
  В единственной строке записано количество долек апельсина (N).
  
  ### Формат вывода
  Таблица вариантов разделения апельсина.
  
  ### Примечания
  Каждому ребёнку должна достаться хотя бы одна долька апельсина. 
  Ни одной дольки не должно остаться. 
  Выводить варианты в порядке увеличения количества долек у Ани, следом Бори и затем Вовы. 
  Для удобства сведите задачу к разделению долек между двумя ребятами, а третьему отдайте остатки.


</details>

<details>
  <summary>Решение</summary>

  ```python
  from itertools import product

  num = int(input())
  nums = range(1, num - 1)
  table = list(product(nums, repeat=3))
  
  print('А Б В')
  for i in range(len(table)):
      if sum(table[i]) == num:
          print(*table[i])
  ```

</details>

## Числовой прямоугольник 3.0

<details>
  <summary>Условие</summary>
  Ребята в детском саду вновь учатся считать, и воспитательница решила сделать так, чтобы им было проще освоить новый навык. Для этого она хочет оформить список изучаемых чисел особым образом. 
  Дети справляются весьма быстро, поэтому ей требуется программа, которая способна строить числовые прямоугольники. Напишите программу, которая строит числовой прямоугольник требуемого размера.
  
  ### Формат ввода
  В первой строке записано число N — высота числового прямоугольника. 
  Во второй строке указано число M — ширина числового прямоугольника.
  
  ### Формат вывода
  Нужно вывести сформированный числовой прямоугольник требуемого размера.
  Чтобы прямоугольник был красивым, каждый его столбец должен быть одинаковой ширины.
  
  ### Примечание
  itertools.product прекрасно подходит, чтобы избавиться от вложенных циклов.


</details>

<details>
  <summary>Решение</summary>

  ```python
  from itertools import product

  x = int(input())
  y = int(input())
  
  ln = len(str(x * y))
  
  for i, j in product(range(1, x + 1), range(1, y + 1)):
      print(f'{((i - 1) * y + j):>{ln}}', end=' ')
      if j == y:
          print()
  ```

</details>

## Список покупок 2.0

<details>
  <summary>Условие</summary>
  Давайте вновь поможем человеку с покупками. Разработайте программу, которая собирает пожелания семьи в единый список.

  ### Формат ввода
  В первой строке задано натуральное число N — количество членов семьи. В следующих N строках записаны желаемые продукты (через запятую и пробел).
  
  ### Формат вывода
  Отсортированный по алфавиту список продуктов с нумерацией.
  
  ### Примечание
  Помните, что итераторы можно хранить в списке, а его можно распаковать в любую функцию.


</details>

<details>
  <summary>Решение</summary>

  ```python
  string = []

  for i in range(int(input())):
      string.extend(input().split(', '))
  
  lst = enumerate(sorted(string), 1)
  
  print('\n'.join([f'{num}. {item}' for num, item in lst]))
  ```

</details>

## Расстановка спортсменов

<details>
  <summary>Условие</summary>
  Расстановка спортсменов на старте — сложная задача. Однако при помощи итераторов она решается за пару строк. Напишите программу, которая выводит список возможных расстановок спортсменов на старте.

  ### Формат ввода
  В первой строке задано натуральное число N — количество спортсменов. В следующих N строках записаны имена спортсменов.
  
  ### Формат вывода
  Отсортированный по алфавиту список расстановок. 
  Имена в каждой строке выводить через запятую и пробел.


</details>

<details>
  <summary>Решение</summary>

  ```python
  import itertools

  n = int(input())
  names = []
  for name in range(n):
      names.append(input())
  
  values = itertools.permutations(names)
  for value in sorted(values):
      temp = ', '.join(value)
      print(temp)
  ```

</details>

## Спортивные гадания

<details>
  <summary>Условие</summary>
  Хорошо, спортсмены расставлены на старте. Вот только угадать финалистов практически невозможно. Давайте напишем программу, которая выводит список возможных победителей.

  ### Формат ввода
  В первой строке задано натуральное число N — количество спортсменов. В следующих N строках записаны имена спортсменов.
  
  ### Формат вывода
  Отсортированный по алфавиту список вариантов. 
  Имена в каждой строке выводить через запятую и пробел.


</details>

<details>
  <summary>Решение</summary>

  ```python
  import itertools

  n = int(input())
  names = []
  for name in range(n):
      names.append(input())
  
  values = itertools.permutations(names, 3)
  for value in sorted(values):
      temp = ', '.join(value)
      print(temp)

  ```

</details>

## Список покупок 3.0

<details>
  <summary>Условие</summary>
  В этот раз семья договорилась о том, что в целях экономии бюджета, они будут совершать в день только три покупки. Напишите программу, которая готовит варианты списков покупок.

  ### Формат ввода
  В первой строке задано натуральное число N — количество членов семьи. В следующих N строках записаны желаемые продукты (через запятую и пробел).
  
  ### Формат вывода
  Варианты списков покупок в алфавитном порядке.


</details>

<details>
  <summary>Решение</summary>

  ```python
  import itertools

  n = int(input())
  to_buy = []
  for name in range(n):
      for i in input().split(", "):
          to_buy.append(i)
  
  values = itertools.permutations(to_buy, 3)
  for value in sorted(values):
      temp = ' '.join(value)
      print(temp)
  ```

</details>

## Расклад таков...

<details>
  <summary>Условие</summary>
  Виталий любит играть в карты. Он решил выяснить, какие есть вариации вытащить из колоды определённые тройки карт. Напишите программу, которая выводит список вариантов согласно требованиям.

  ### Формат ввода
  В первой строке записана масть, которая должна присутствовать в тройке. 
  Во второй строке записан достоинство, которого не должно быть в тройке.
  
  ### Формат вывода
  Выведите на экран первые 10 получившихся троек. 
  Карты в каждой комбинации должны быть отсортированы лексикографически (по строке названия карты). Карты комбинации выводятся через запятую с пробелом после неё. 
  Комбинации между собой также должны быть отсортированы в лексикографическом порядке по строке, представляющей комбинацию целиком.
  
  ### Примечание
  Обратите внимание: валет-дама-король-туз лексикографически упорядочены. Но «10 ...» лексикографически младше, чем «2 ...», а бубны младше, чем пики.
  
  Масти в именительном и родительном падежах:

  Именительный	Родительный
  буби	        бубен
  пики	        пик
  трефы	        треф
  черви      	  червей


</details>

<details>
  <summary>Решение</summary>

  ```python
  import itertools

  nomin = ["10", "2", "3", "4", "5", "6", "7", "8", "9", "валет", "дама", "король", "туз"]
  mast = ["бубен", "пик", "треф", "червей"]
  
  mast_names = {"буби": "бубен", "пики": "пик", "трефы": "треф", "черви": "червей"}
  
  needed_mast = mast_names[input()]
  nomin.remove(str(input()))
  
  deck = list(itertools.product(nomin, mast))
  deck_fixed = [' '.join(value) for value in deck]
  comb = list(itertools.permutations(deck_fixed, 3))
  m = 0
  for value in comb:
      if needed_mast in ", ".join(value):
          print(', '.join(value))
          m += 1
          if m == 10:
              break

  ```

</details>

## А есть ещё варианты?

<details>
  <summary>Условие</summary>
  А есть ещё варианты? 
  Давайте вновь поможем Виталию выяснить, какие вариации вытащить из колоды определённые тройки карт возможны. Напишите программу, которая выводит список вариантов согласно требованиям.
  
  ### Формат ввода
  В первой строке записана масть, которая должна присутствовать в тройке. Во второй строке записан достоинство, которого не должно быть в тройке. В третьей строке записан предыдущий вариант полученный Виталием.
  
  ### Формат вывода
  Выведите следующий вариант расклада.
  
  ### Примечание
  Обратите внимание: валет-дама-король-туз лексикографически упорядочены. Но «10 ...» лексикографически младше, чем «2 ...», а бубны младше, чем пики.
  
  Масти в именительном и родительном падежах:

  Именительный	Родительный
  буби	        бубен
  пики	        пик
  трефы	        треф
  черви      	  червей


</details>

<details>
  <summary>Решение</summary>

  ```python
  import itertools

  nomin = ["10", "2", "3", "4", "5", "6", "7", "8", "9", "валет", "дама", "король", "туз"]
  mast = ["бубен", "пик", "треф", "червей"]
  
  mast_names = {"буби": "бубен", "пики": "пик", "трефы": "треф", "черви": "червей"}
  
  needed_mast = mast_names[input()]
  nomin.remove(str(input()))
  
  deck = list(itertools.product(nomin, mast))
  deck_fixed = [' '.join(value) for value in deck]
  comb = list(itertools.combinations(deck_fixed, 3))
  comb_fixed = sorted([', '.join(sorted(value)) for value in comb])
  needed_comb = input()
  
  needed_index = comb_fixed.index(needed_comb) + 1
  for value in comb_fixed[needed_index:]:
      if needed_mast in value:
          print(value)
          break

  ```

</details>

## Таблица истинности

<details>
  <summary>Условие</summary>
  Вся современная электронно-вычислительная техника строится на Булевой алгебре, которая оперирует истинностью и ложностью высказываний. Любой язык программирования содержит логические операции (в Python это and, or, not).

  Чаще всего для работы со сложными высказываниями прибегают к методу под названием «Таблица истинности». 
  Суть метода проста — рассматриваются все возможные значения входных переменных и для них вычисляется результат.
  
  Разработайте программу, которая для введённого сложного логического высказывания строит таблицу истинности.
  
  ### Формат ввода
  Вводится логическое выражение от трех переменных (a, b, c) валидное для языка Python.
  
  ### Формат вывода
  Выведите таблицу истинности данного выражения.
  
  ### Примечание
  Для выполнения Python кода, записанного в строках, существуют две замечательные функции: exec и eval.


</details>

<details>
  <summary>Решение</summary>

  ```python
  import itertools

  f = input()
  
  oper = list(itertools.product((0, 1), repeat = 3))
  print(f'a b c f')
  for value in oper:
      a, b, c = [numb for numb in value]
      if eval(f) == 1:
          print(f'{a} {b} {c} 1')
      else:
          print(f'{a} {b} {c} 0')
  ```

</details>

## Таблица истинности 2

<details>
  <summary>Условие</summary>
  Продолжим работу с таблицами истинности. Продумайте программу, которая для введённого сложного логического высказывания строит таблицу истинности.

  ### Формат ввода
  Вводится логическое выражение от нескольких переменных валидное для языка Python.
  
  ### Формат вывода
  Выведите таблицу истинности данного выражения.
  
  ### Примечание
  В выражении все переменные заданы заглавными латинскими буквами. 
  Обратите внимание на параметры __globals и __locals у функции eval.


</details>

<details>
  <summary>Решение</summary>

  ```python
  import itertools

  letters = set()
  
  for letter in (F := input()):
      if letter.isupper():
          letters.add(letter)
  
  letters = sorted(letters)
  
  oper = list(itertools.product((0, 1), repeat=len(letters)))
  
  print(f'{" ".join(letters)} F')
  
  for value in oper:
      locals_for_eval = dict(zip(letters, value))
      if eval(F, locals_for_eval) == 1:
          print(f'{" ".join(str(x) for x in value)} 1')
      else:
          print(f'{" ".join(str(x) for x in value)} 0')

  ```

</details>

## Таблицы истинности 3

<details>
  <summary>Условие</summary>
  Продолжим работу с таблицами истинности. 
  К сожалению, некоторые из операций Булевой алгебры не реализованы в Python. 
  Самые частые не стандартные операции это: импликация, строгая дизъюнкция и эквивалентность.
  
  Обозначим их следующим образом:
  
  - импликация — ->;
  - строгая дизъюнкция — ^;
  - эквивалентность — ~.
    
  Напишите программу, которая для введённого сложного логического высказывания строит таблицу истинности.
  
  ### Формат ввода
  Вводится логическое выражение от нескольких переменных.
  
  Возможное содержание выражения:
  
  - Заглавная латинская буква — переменная;
  - not — отрицание;
  - and — конъюнкция;
  - or — дизъюнкция;
  - ^ — строгая дизъюнкция;
  - -> — импликация;
  - ~ — эквивалентность;
  - () — логические скобки.
  
  ### Формат вывода
  Выведите таблицу истинности данного выражения.
  
  ### Примечание
  Прежде, чем реализовывать новые операции, обратите внимание на их приоритет. 
  Рекомендуем воспользоваться знаниями полученными при решении задачи «Польский калькулятор».


</details>

<details>
  <summary>Решение</summary>

  ```python
  from itertools import product


  def string_transform(list_of_elements, dict_of_priority, locals_for_transform):
      while len(list_of_elements) != 1:
          list_of_elements_copy = list_of_elements
          for key_element, value_element in dict_of_priority.items():
              for element in list_of_elements:
                  if not element.isupper() and element in list_of_elements:
                      temp_index = list_of_elements.index(element)
                      if element == key_element:
                          if value_element == 0:
                              to_swap = f'not {list_of_elements[temp_index + 1]}'
                              temp_value = eval(to_swap, locals_for_transform)
                              list_of_elements_copy = " ".join(list_of_elements_copy).replace(to_swap, f'{temp_value}')
                              list_of_elements_copy = list_of_elements_copy.split(" ")
                              list_of_elements = list_of_elements_copy
                          elif value_element in (1, 2, 3, 4, 5):
                              to_swap = f'{list_of_elements[temp_index - 1]} {element} {list_of_elements[temp_index + 1]}'
                              temp_value = eval(to_swap, locals_for_transform)
                              list_of_elements_copy = " ".join(list_of_elements_copy).replace(to_swap, f'{temp_value}')
                              list_of_elements_copy = list_of_elements_copy.split(" ")
                              list_of_elements = list_of_elements_copy
  
      return list_of_elements
  
  
  operators = {'not': 'not', 'and': 'and', 'or': 'or',
               '^': '!=', '->': '<=', '~': '=='}
  
  priority = {'not': 0, 'and': 1, 'or': 2, '!=': 3, '<=': 4, '==': 5}
  
  expression = input().replace('(', '( ').replace(')', ' )').split(" ")
  
  letters = set()
  
  
  for letter in expression:
      if letter.isupper():
          letters.add(letter)
  
  
  letters = sorted(letters)
  
  zeros_and_ones = list(product((0, 1), repeat=len(letters)))
  
  print(f'{" ".join(letters)} F')
  
  for value in zeros_and_ones:
      expression_fixed = list()
      for letter in expression:
          if letter in operators:
              letter = operators[letter]
          expression_fixed.append(letter)
      locals_for_eval = dict(zip(letters, value))
      while " ".join(expression_fixed).find("(") != -1:
          left_bracket = 0
          right_bracket = 0
          count = 0
          for letter in expression_fixed:
              temp = expression_fixed.index(letter, count)
              if right_bracket == 0:
                  if letter == "(":
                      left_bracket = temp
                  elif letter == ")":
                      right_bracket = temp
                  count += 1
              else:
                  break
  
          to_eval = expression_fixed[left_bracket + 1:right_bracket]
  
          to_eval_copy = " ".join(string_transform(to_eval, priority, locals_for_eval))
  
          to_eval = " ".join(to_eval)
  
          expression_fixed = " ".join(expression_fixed).replace(f'( {to_eval} )', f'{to_eval_copy}')
          expression_fixed = expression_fixed.split(" ")
  
      F = eval(" ".join(string_transform(expression_fixed, priority, locals_for_eval)), locals_for_eval)
      print(f'{" ".join(str(x) for x in value)} {int(F)}')

  ```

</details>
