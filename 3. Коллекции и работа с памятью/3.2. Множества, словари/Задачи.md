## Символическая выжимка

<details>
  <summary>Условие</summary>
  Во многих промышленных задачах требуется понимать, из каких символов состоят данные. Напишите программу, чтобы по введённой строке она определяла, из каких символов та состоит.
  
  ### Формат ввода
  Вводится одна строка.
  
  ### Формат вывода
  Требуется вывести все символы этой строки без повторений. 
  Порядок вывода не имеет значения.


</details>

<details>
  <summary>Решение</summary>

  ```python
  word = set(input())
  print(''.join(word))
  ```
</details>

## Символическая разница

<details>
  <summary>Условие</summary>
  А ещё в промышленных задачах часто требуется находить общее среди данных, полученных из разных источников. Напишите программу, которая по двум строкам определяет их общие символы.

  ### Формат ввода
  Вводится две строки.
  
  ### Формат вывода
  Требуется вывести все символы этой строки без повторений. 
  Порядок вывода не имеет значения.


</details>

<details>
  <summary>Решение</summary>

  ```python
  word_1 = set(input())
  word_2 = set(input())
  
  print(''.join(word_1 & word_2))
  ```
</details>

## Зайка — 8

<details>
  <summary>Условие</summary>
  Продолжаем считать заек за окном поезда.

  ### Формат ввода
  В первой строке записано натуральное число N — количество выделенных придорожных местностей. 
  В каждой из N последующих строк записано описание придорожной местности.
  
  ### Формат вывода
  Вывести все найденные объекты в придорожных местностях.


</details>

<details>
  <summary>Решение</summary>

  ```python
  words = set()
  n = int(input())
  for i in range(n):
      temp = set(input().split())
      for word in temp:
          words.add(word)
  print("\n".join(words))

  ```
</details>

## Кашееды

<details>
  <summary>Условие</summary>
  Каждый воспитанник детского сада любит либо манную, либо овсяную, либо обе каши. 
  Давайте создадим программу, которая позволит воспитателю быстро выяснить, сколько детей любят обе каши.
  
  ### Формат ввода
  В первых двух строках указывается количество детей, любящих манную и овсяную каши (N и M). 
  Затем идут N строк — фамилии детей, которые любят манную кашу, и M строк с фамилиями детей, любящих овсяную кашу. 
  Гарантируется, что в группе нет однофамильцев.
  
  ### Формат вывода
  Количество учеников, которые любят обе каши. 
  Если таких не окажется, в строке вывода нужно написать «Таких нет».


</details>

<details>
  <summary>Решение</summary>

  ```python
  n = int(input())
  m = int(input())
  mana = set()
  oves = set()
  for i in range(n):
      mana.add(input())
  for i in range(m):
      oves.add(input())
  if mana & oves == set():
      print(f"Таких нет")
  else:
      print(len(mana & oves))

  ```
</details>

## Кашееды — 2

<details>
  <summary>Условие</summary>
  Изменим задачу и напишем программу, которая поможет быстро выяснить, сколько детей любят только одну кашу.

  ### Формат ввода
  В первых двух строках указывается количество детей, любящих манную и овсяную каши (N и M). 
  Затем идут N+M строк — перемешанные фамилии детей. 
  Гарантируется, что в группе нет однофамильцев.
  
  ### Формат вывода
  Количество учеников, которые любят только одну кашу. 
  Если таких не окажется, в строке вывода нужно написать «Таких нет».


</details>

<details>
  <summary>Решение</summary>

  ```python
  n = int(input())
  m = int(input())
  names = set()
  count = 0
  for i in range(n + m):
      temp = input()
      if temp in names:
          count -= 1
      if temp not in names:
          names.add(temp)
          count += 1
  if count > 0:
      print(f"{count}")
  else:
      print(f"Таких нет")

  ```
</details>

## Кашееды — 3

<details>
  <summary>Условие</summary>
  Вернёмся к условию, когда каждый воспитанник детского сада любит либо манную, либо овсяную, либо обе эти каши. 
  Напишите программу, которая позволит воспитателю узнать, какие дети любят только одну кашу.
  
  ### Формат ввода
  В первых двух строках указывается количество детей, любящих манную и овсяную каши (N и M). 
  Затем идут N+M строк — перемешанные фамилии детей. 
  Гарантируется, что в группе нет однофамильцев.
  
  ### Формат вывода
  В алфавитном порядке фамилии учеников, которые любят только одну кашу. 
  Если таких не окажется, в строке вывода нужно написать «Таких нет».


</details>

<details>
  <summary>Решение</summary>

  ```python
  n = int(input())
  m = int(input())
  names = set()
  count = 0
  for i in range(n + m):
      temp = input()
      if temp in names:
          count -= 1
          names.discard(temp)
          continue
      if temp not in names:
          names.add(temp)
          count += 1
  if count > 0:
      print("\n".join(sorted(names)))
  else:
      print(f"Таких нет")

  ```
</details>

## Азбука Морзе

<details>
  <summary>Условие</summary>
  Вам дан английский текст. Закодируйте его с помощью азбуки Морзе Каждая буква заменяется на последовательность точек и тире. В качестве тире используйте обычный дефис: -, а в качестве точки — точку .. Например, буква g превратится в трёхсимвольную строку --.. Между закодированными буквами ставится ровно один пробел. Например, слово Help превратится в .... . .-.. .--.. Обратите внимание, что строчные и заглавные буквы кодируются одинаково.

  ### Формат ввода
  Весь текст записан в единственной строке. Текст состоит из английских букв и пробелов, других символов в тексте нет. В тексте не может быть двух или более пробелов подряд.
  
  ### Формат вывода
  Выведите каждое слово исходного текста, закодированное азбукой Морзе, на отдельной строке. 
  Количество строк в ответе должно совпадать с количеством слов в исходном тексте.
  
  ### Примечание
  Один из вариантов словаря с Азбукой Морзе:
  ```
    'A': '.-', 'B': '-...', 'C': '-.-.',
    'D': '-..', 'E': '.', 'F': '..-.',
    'G': '--.', 'H': '....', 'I': '..',
    'J': '.---', 'K': '-.-', 'L': '.-..',
    'M': '--', 'N': '-.', 'O': '---',
    'P': '.--.', 'Q': '--.-', 'R': '.-.',
    'S': '...', 'T': '-', 'U': '..-',
    'V': '...-', 'W': '.--', 'X': '-..-',
    'Y': '-.--', 'Z': '--..',
    '0': '-----', '1': '.----', '2': '..---',
    '3': '...--', '4': '....-', '5': '.....',
    '6': '-....', '7': '--...', '8': '---..',
    '9': '----.'
  ```
</details>

<details>
  <summary>Решение</summary>

  ```python
  morse = {
      'A': '.-', 'B': '-...', 'C': '-.-.',
      'D': '-..', 'E': '.', 'F': '..-.',
      'G': '--.', 'H': '....', 'I': '..',
      'J': '.---', 'K': '-.-', 'L': '.-..',
      'M': '--', 'N': '-.', 'O': '---',
      'P': '.--.', 'Q': '--.-', 'R': '.-.',
      'S': '...', 'T': '-', 'U': '..-',
      'V': '...-', 'W': '.--', 'X': '-..-',
      'Y': '-.--', 'Z': '--..',
      '0': '-----', '1': '.----', '2': '..---',
      '3': '...--', '4': '....-', '5': '.....',
      '6': '-....', '7': '--...', '8': '---..',
      '9': '----.', '-': '-', '.': '.'}
  text = input().split()
  for word in text:
      temp = ""
      for letter in word:
          temp += morse[letter.upper()] + " "
      temp = temp.rstrip(" ")
      print(temp)

  ```
</details>

## Кашееды — 4

<details>
  <summary>Условие</summary>
  Каждый воспитанник детского сада любит одну или несколько каш. 
  Поможем воспитателю составить список детей, которые любят конкретную кашу.
  
  ### Формат ввода
  В первой строке задаётся количество детей в группе (N). В следующих N строках записана фамилия ребенка и список его любимых каш. В последней строке записана каша, информацию о которой хочет получить воспитатель.
  
  ### Формат вывода
  Фамилии учеников, которые любят заданную кашу, в алфавитном порядке. 
  Если таких не окажется, в строке вывода нужно написать «Таких нет».


</details>

<details>
  <summary>Решение</summary>

  ```python
  names = dict()
  n = int(input())
  for i in range(n):
      temp = input().split()
      names[temp[0]] = temp[1:]
  need = input()
  needed_names = set()
  for key, value in names.items():
      if need in value:
          needed_names.add(key)
  if needed_names != set():
      print("\n".join(sorted(needed_names)))
  else:
      print(f"Таких нет")
  ```

</details>

## Зайка — 9

<details>
  <summary>Условие</summary>
  Поможем детям подсчитать, сколько за окном поезда встречается животных и деревьев каждого вида.

  ### Формат ввода
  В каждой строке записано описание придорожной местности. 
  Конец ввода обозначается пустой строкой.
  
  ### Формат вывода
  Список увиденного и их количество. 
  Порядок вывода не имеет значения.


</details>

<details>
  <summary>Решение</summary>

  ```python
  names = dict()
  while temp_line := input().split():
      count = 0
      for temp in temp_line:
          if temp not in names:
              names[temp] = 1
              continue
          if temp in names:
              names[temp] += 1
  for key, value in names.items():
      print(key, value)
    
  ```

</details>

## Транслитерация

<details>
  <summary>Условие</summary>
  Для международных документов русский текст преобразуется с использованием латинского алфавита. 
  ГОСТ Р 52535.1-2006 задаёт правила транслитерации идентификационных карт. 
  Ниже приведена таблица замен:
  
  - А — A
  - Б — B
  - В — V
  - Г — G
  - Д — D
  - Е — E
  - Ё — E
  - Ж — ZH
  - З — Z
  - И — I
  - Й — I
  - К — K
  - Л — L
  - М — M
  - Н — N
  - О — O
  - П — P
  - Р — R
  - С — S
  - Т — T
  - У — U
  - Ф — F
  - Х — KH
  - Ц — TC
  - Ч — CH
  - Ш — SH
  - Щ — SHCH
  - Ы — Y
  - Э — E
  - Ю — IU
  - Я — IA

  Давайте транслитерируем русский текст.
  
  Букву «ё» транслитерируйте как «e», «й» как «и», а «ъ» и «ь» (и их заглавные версии «Ъ» и «Ь») должны исчезнуть из текста. Строчные буквы заменяются на строчные, заглавные заменяются на заглавные. Если заглавная буква превращается при транслитерации в несколько букв, то заглавной должна остаться только первая из них (например, «Ц» → «Tc»). Все некириллические символы должны остаться на месте.
  
  ### Формат ввода
  В единственной строке задан русский текст. Текст может состоять из любых символов. Вам необходимо транслитерировать только русские буквы, а остальные оставить на месте. Гарантируется, что нет слов, состоящих только из букв «ъ» и «ь».
  
  ### Формат вывода
  Выведите одну строку — транслитерированный текст.


</details>

<details>
  <summary>Решение</summary>

  ```python
  TRANSLITERATE_DICT = {
      'А': 'A', 'Б': 'B', 'В': 'V', 'Г': 'G', 'Д': 'D', 'Е': 'E', 'Ё': 'E',
      'Ж': 'ZH', 'З': 'Z', 'И': 'I', 'Й': 'I', 'К': 'K', 'Л': 'L', 'М': 'M',
      'Н': 'N', 'О': 'O', 'П': 'P', 'Р': 'R', 'С': 'S', 'Т': 'T', 'У': 'U',
      'Ф': 'F', 'Х': 'KH', 'Ц': 'TC', 'Ч': 'CH', 'Ш': 'SH', 'Щ': 'SHCH',
      'Ы': 'Y', 'Э': 'E', 'Ю': 'IU', 'Я': 'IA', 'Ь': '', 'Ъ': ''
  }
  
  
  result = ''
  
  for char in input():
      char_copy = char.upper()
      if char_copy in TRANSLITERATE_DICT:
          if char.isupper():
              char = TRANSLITERATE_DICT[char_copy].capitalize()
          else:
              char = TRANSLITERATE_DICT[char_copy].lower()
      result += char
  
  print(result)

  ```

</details>

## Однофамильцы

<details>
  <summary>Условие</summary>
  Начальник кадровой службы хочет выяснить, сколько мужчин-однофамильцев работает в организации. У него есть список фамилий, и на основании этого списка нужно вычислить количество фамилий, которые совпадают с другими.

  ### Формат ввода
  В первой строке указывается количество мужчин — сотрудников организации (N). 
  Затем идут N строк с фамилиями этих сотрудников в произвольном порядке.
  
  ### Формат вывода
  Количество однофамильцев в организации.


</details>

<details>
  <summary>Решение</summary>

  ```python
  n = int(input())
  names = dict()
  count = 0
  for i in range(n):
      if (text := input()) not in names:
          names[text] = [i]
      else:
          names[text].append(i)
  for numb in names:
      if len(names[numb]) > 1:
          count += len(names[numb])
  print(count)
  ```

</details>

## Однофамильцы — 2

<details>
  <summary>Условие</summary>
  Вновь поможем сотруднику из отдела кадров выяснить, сколько мужчин-однофамильцев работает в организации, но уже немного с иными условиями.

  ### Формат ввода
  В первой строке указывается количество мужчин — сотрудников организации (N). 
  Затем идут N строк с фамилиями этих сотрудников в произвольном порядке.
  
  ### Формат вывода
  Список однофамильцев в организации с указанием их количества в алфавитном порядке. 
  Если таковых нет — вывести «Однофамильцев нет».


</details>

<details>
  <summary>Решение</summary>

  ```python
  n = int(input())
  names = dict()
  count = 0
  for i in range(n):
      if (text := input()) not in names:
          names[text] = [i]
      else:
          names[text].append(i)
  names = dict(sorted(names.items()))
  for numb in names:
      if len(names[numb]) > 1:
          print(f'{numb} - {len(names[numb])}')
          count += 1
  if count == 0:
      print(f'Однофамильцев нет')
    
  ```

</details>

## Дайте чего-нибудь новенького!

<details>
  <summary>Условие</summary>
  Главный повар детского сада хочет приготовить в праздничный день блюда, которые ни разу не готовил на этой неделе.
  В его распоряжении есть список блюд:
   
  - которые можно приготовить в столовой сегодня;
  - которые были приготовлены в каждый из дней недели.
  
  ### Формат ввода
  Число блюд (N), которые можно приготовить в столовой.  
  N строк с названиями блюд. Число дней (M), о которых имеется информация. 
  M блоков строк для каждого из списков. В первой строке каждого блока записано число блюд в заданный день, затем перечисляются эти блюда.
  
  ### Формат вывода
  Список блюд, которые ещё не готовились на этой неделе в алфавитном порядке. 
  Если все возможные блюда уже были приготовлены, следует вывести «Готовить нечего».


</details>

<details>
  <summary>Решение</summary>

  ```python
  n = int(input())
  blyoda = set()
  for i in range(n):
      blyoda.add(input())
  already_did = set()
  m = int(input())
  for i in range(m):
      temp = int(input())
      for j in range(temp):
          already_did.add(input())
  if (blyoda - already_did) == set():
      print(f'Готовить нечего')
  else:
      print("\n".join(sorted(blyoda - already_did)))
  ```

</details>

## Это будет шедевр!

<details>
  <summary>Условие</summary>
  Главный повар детского сада хочет быстрее выбирать блюда для готовки. 
  В его распоряжении есть список продуктов, а также набор блюд.
  
  Напишите программу, способную быстро определить блюда, которые можно приготовить.
  
  ### Формат ввода
  Число продуктов (N), которые имеются в наличии. 
  N строк с названиями продуктов. 
  Число рецептов (M), о которых имеется информация. 
  M блоков строк для каждого из рецептов. 
  В первой строке каждого блока записано название блюда. 
  Во второй — число ингредиентов. 
  Затем перечисляются сами ингредиенты, требуемые для приготовления блюда.
  
  ### Формат вывода
  Список блюд, которые можно приготовить в алфавитном порядке. 
  Если ни одно из блюд нельзя приготовить, следует вывести «Готовить нечего».


</details>

<details>
  <summary>Решение</summary>

  ```python
  n = int(input())
  ingredients = set()
  count = 0
  for i in range(n):
      ingredients.add(input())
  blyoda = dict()
  m = int(input())
  for i in range(m):
      temp = input()
      number = int(input())
      for j in range(number):
          if temp not in blyoda:
              blyoda[temp] = [input()]
          else:
              blyoda[temp].append(input())
  
  for ing in dict(sorted(blyoda.items())):
      if (ingredients & set(blyoda[ing])) == set(blyoda[ing]):
          print(f'{ing}')
          count += 1
  if count == 0:
      print(f'Готовить нечего')
  ```

</details>

## Двоичная статистика!

<details>
  <summary>Условие</summary>
  У программистов особые отношения с двоичной системой счисления. 
  Продолжим тренировки в статистической обработке данных и проанализируем данные числа. 
  Напишите программу, которая для переданных чисел вычисляет:
  
  - количество разрядов;
  - количество единиц;
  - количество нулей.
    
  ### Формат ввода
  Вводится последовательность чисел, записанных через пробел.
  
  ### Формат вывода
  Вывести список словарей с требуемой статистикой.
  
  ### Примечание
  Вывод в примерах отформатирован только для визуальной наглядности. 
  Все пробельные символы при проверке игнорируются. 
  Порядок словарей обязан совпадать с порядком переданных чисел. 
  Порядок ключей в словаре не имеет значения.


</details>

<details>
  <summary>Решение</summary>

  ```python
  def numbertobase(n, b):
      if n == 0:
          return [0]
      digits = []
      while n:
          digits.append(int(n % b))
          n //= b
      return digits[::-1]
  
  
  numbers = input().split()
  
  list_of_numbers = list()
  
  for number in numbers:
      number_dict = dict()
      digits = 0
      units = 0
      zeros = 0
  
      new_number = numbertobase(int(number), 2)
      for digit in new_number:
          digits = len(new_number)
          if digit == 1:
              units += 1
          else:
              zeros += 1
  
      number_dict["digits"] = digits
      number_dict["units"] = units
      number_dict["zeros"] = zeros
      list_of_numbers.append(number_dict)
      
  print(list_of_numbers)
  ```

</details>

## Зайка — 10

<details>
  <summary>Условие</summary>
  Поможем детям разобраться, что именно они увидели рядом с зайками.

  ### Формат ввода
  В каждой строке записано описание придорожной местности. 
  Конец ввода обозначается пустой строкой.
  
  ### Формат вывода
  Определите список увиденного рядом с зайками без повторений. 
  Порядок вывода не имеет значения.
  
  ### Примечание
  Считается, что объект находится рядом, если он записан справа или слева от требуемого.


</details>

<details>
  <summary>Решение</summary>

  ```python
  need = set()
  while text := input().split():
      for word in text:
          if word == "зайка":
              place = text.index(word)
              if place == len(text) - 1 and place != 0:
                  need.add(text[place - 1])
              elif place == 0:
                  need.add(text[place + 1])
              else:
                  need.add(text[place - 1])
                  need.add(text[place + 1])
              text.pop(place)
  print("\n".join(sorted(need)))
  ```

</details>

## Друзья друзей

<details>
  <summary>Условие</summary>
  Теория шести рукопожатий — социологическая теория, согласно которой любые два человека на Земле разделены не более, чем пятью уровнями общих знакомых (и, соответственно, шестью уровнями связей). Формальная математическая формулировка теории: диаметр графа знакомств не превышает 6. Мы не станем так сильно углубляться в дружественные связи и пока нам хватит только двух уровней. Напишите программу, которая по списку дружественных пар для каждого человека определяет список «друзей 2-го уровня».

  ### Формат ввода
  В каждой строке записывается два имени. 
  Окончанием ввода служит пустая строка.
  
  ### Формат вывода
  Выведите список всех людей и их «друзей 2-го уровня» в формате «Человек: Друг1, Друг2, ...». 
  Список людей и друзей в каждой строке требуется вывести в алфавитном порядке без повторений.


</details>

<details>
  <summary>Решение</summary>

  ```python
  friends = {}

  while pair := input():
      friend1, friend2 = pair.split()
      friends[friend1] = friends.get(friend1, set()) | set([friend2])
      friends[friend2] = friends.get(friend2, set()) | set([friend1])
  
  friends_of_friends = {}
  
  for name in sorted(friends):
      for person in friends[name]:
          friends_of_friends[name] = friends_of_friends.get(
              name, set()) | friends[person]
  
  for name in friends_of_friends:
      friends_of_friends[name].discard(name)
      friends_of_friends[name] -= friends[name]
  
      friends_of_friends[name] = sorted(friends_of_friends[name])
  
      print(f'{name}: {", ".join(friends_of_friends[name])}')
  ```

</details>

## Карта сокровищ

<details>
  <summary>Условие</summary>
  На пиратской карте отмечено N точек, в которых зарыты сокровища. Каждая точка задана координатами (xi, yi). Координаты указаны в километрах. Команда Капитана Крюка хочет составить маршрут, чтобы собрать как можно больше кладов. Однако есть ограничение: для любых двух соседних точек маршрута (xi, yi) и (xj, yj) координаты xi и xj  могут различаться только последней цифрой, как и координаты yi и yj тоже могут различаться только последней цифрой. Например, после точки (15, 10) они могут отправиться в точку (18, 16), а вот из точки (14, 68) в точку (19, 71) пройти уже не получится, ведь 68 и 71 различаются не только последней цифрой. Из точки (5, 12) в точку (13, 14) попасть тоже нельзя, так как числа 5 и 13 отличаются в разряде десятков. По заданным координатам определите, какое максимальное количество точек сможет добавить в свой маршрут Капитан Крюк.
  
  ### Формат ввода
  В первой строке указано число N (1≤N≤10 ) — количество точек, отмеченных на карте сокровищ. В следующих N строках содержатся пары координат: xi  и yi  — координаты i-ой точки. Координаты — целые числа не меньше нуля и не больше 10^9. Гарантируется, что совпадающих точек в списке нет.
  
  ### Формат вывода
  Выведите одно число — максимальное количество точек, которое Капитан Крюк сможет посетить по маршруту, построенному по описанным правилам.


</details>

<details>
  <summary>Решение</summary>

  ```python
  treasures = dict()

  for i in range(count := int(input())):
      x, y = input().split()
      index = (int(x) // 10, int(y) // 10)
      treasures[index] = treasures.get(index, 0) + 1
  
  print(max(treasures.values()))
  ```

</details>

## Частная собственность

<details>
  <summary>Условие</summary>
  Ребята приносят игрушки в детский сад и играют все вместе. 
  Сегодня они решили выяснить, игрушки какого типа принадлежат только одному из детей. Напишите программу, которая по списку детей и их игрушек определит «частную собственность».
  
  ### Формат ввода
  В первой строке задается количество детей в группе (N). 
  В каждой из следующих N строк записано имя ребенка и его игрушки в формате: 
  Имя: игрушка1, игрушка2, ....
  
  ### Формат вывода
  Список игрушек, которые есть только у одного из детей в алфавитном порядке.


</details>

<details>
  <summary>Решение</summary>

  ```python
  n = int(input())
  igrushki = dict()
  
  for i in range(n):
      text = input().split(":")
      toys = set()
      for toy in text[1].split(','):
          toys.add(toy.lstrip(" "))
      for toy in toys:
          if toy not in igrushki:
              igrushki[toy] = 1
          else:
              igrushki[toy] += 1
  for key, value in sorted(igrushki.items()):
      if igrushki[key] == 1:
          print(key)
  ```

</details>

## Простая задача 4.0

<details>
  <summary>Условие</summary>
  Напомним, что взаимно простыми называются числа, которые не имеют общих делителей кроме 1. Напишите программу, которая для каждого переданного числа находит список его взаимно простых.

  ### Формат ввода
  Задана последовательность чисел записанных через точку с запятой (;) и пробел.
  
  ### Формат вывода
  Список чисел с указанием взаимно простых ему среди переданных. 
  Все числа должны быть выведены в порядке возрастания без повторений. 
  Строки следует отформатировать по правилу: 
  число - взаимно простое 1, взаимно простое 2, ... 
  
  Если для числа не было найдено ни одного взаимно простого, то и выводить его не требуется.


</details>

<details>
  <summary>Решение</summary>

  ```python
  numbers = list(set(input().split('; ')))

  numbers = sorted(set([int(number) for number in numbers]))
  
  for num1 in numbers:
      gcd = []
      for num2 in numbers:
          if num1 - num2:
              a, b = num1, num2
              while b != 0:
                  a, b = b, a % b
              if a == 1:
                  gcd.append(str(num2))
      if gcd:
          print(num1, '-', ", ".join(gcd))
  ```

</details>

