## Длины всех слов - 2

<details>
  <summary>Условие</summary>
  Напишите функцию length_stats, которая получает текст, а возвращает объект Series со словами в качестве индексов и их длинами в качестве значений.

  Все слова в тексте предварительно переведите в нижний регистр, избавьтесь от знаков препинания и цифр, а также отсортируйте в лексикографическом порядке.
  
  ### Примечание
  Ваше решение должно содержать только функции. 
  В решении не должно быть вызовов требуемых функций.


</details>

<details>
  <summary>Решение</summary>

  ```python
  import pandas as pd


  def length_stats(string_of_words):
      dict_of_words = {}
  
      fixed_string = ''
  
      for letter in string_of_words.lower():
          if not letter.isalpha() and letter != " ":
              fixed_string += ''
          else:
              fixed_string += letter
  
      for data in sorted(fixed_string.split(' ')):
          if data not in dict_of_words and data != "":
              dict_of_words[data] = len(data)
  
      return pd.Series(dict_of_words, dtype='int64')
  ```

</details>

## Длины всех слов по чётности

<details>
  <summary>Условие</summary>
  В этот раз продумайте функцию length_stats, которая получает текст, а возвращает пару объектов Series со словами в качестве индексов и их длинами в качестве значений.

  Все слова в тексте предварительно переведите в нижний регистр, избавьтесь от знаков препинания и цифр, а также отсортируйте в лексикографическом порядке.
  
  ### Примечание
  Ваше решение должно содержать только функции. 
  В решении не должно быть вызовов требуемых функций.
  

</details>

<details>
  <summary>Решение</summary>

  ```python
  import pandas as pd


  def length_stats(string_of_words):
      dict_of_words_odd = {}
      dict_of_words_even = {}
      fixed_string = ''
  
      for letter in string_of_words.lower():
          if not letter.isalpha() and letter != " ":
              fixed_string += ''
          else:
              fixed_string += letter
  
      for data in sorted(fixed_string.split(' ')):
          if data not in (dict_of_words_odd or dict_of_words_even) and data != "":
              if len(data) % 2 == 1:
                  dict_of_words_odd[data] = len(data)
              else:
                  dict_of_words_even[data] = len(data)
  
      return pd.Series(dict_of_words_odd, dtype='int64'), pd.Series(dict_of_words_even, dtype='int64')

  ```

</details>

## Чек - 2

<details>
  <summary>Условие</summary>
  В местном магазине решили добавить анализ данных и каждый чек представлять в виде DataFrame. 
  Прайс-лист уже сформирован в виде объекта Series, где индексами являются названия, а значениями — цены.
  
  Напишите функцию, cheque, которая принимает прайс-лист и список покупок в виде неопределённого количества именованных параметров (ключ — название товара, значение — количество).
  
  Функция должна вернуть объект DataFrame со столбцами:
  
  - наименование продукта (product);
  - цена за единицу (price);
  - количество (number);
  - итоговая цена (cost).
  
  Строки чека должны быть отсортированы по названию продуктов в лексикографическом порядке.
  
  ### Примечание
  Ваше решение должно содержать только функции. 
  В решении не должно быть вызовов требуемых функций.


</details>

<details>
  <summary>Решение</summary>

  ```python
  import pandas as pd


  def cheque(price_list_of_groceries, **kwargs):
      dict_of_groceries = kwargs
      list_of_groceries_sorted = sorted(dict_of_groceries)
      list_of_total_for_grocery = []
      for grocery in list_of_groceries_sorted:
          list_of_total_for_grocery.append(dict_of_groceries[grocery] * price_list_of_groceries[grocery])
  
      return pd.DataFrame({"product": list_of_groceries_sorted,
                           "price": [price_list_of_groceries[data] for data in list_of_groceries_sorted],
                           "number": [dict_of_groceries[data] for data in list_of_groceries_sorted],
                           "cost": list_of_total_for_grocery})
  ```

</details>

## Акция

<details>
  <summary>Условие</summary>
  Магазин, для которого вы писали функцию в предыдущей задаче, проводит акцию:

  При покупке больше двух товаров — скидка 50%
  
  мелкий шрифт: скидка распространяется только на товары купленные в количестве более двух штук
  
  Напишите функцию discount, принимающую чек из прошлой задачи и возвращающую новый с учётом акции.
  
  ### Примечание
  Не удаляйте функцию cheque, она потребуется для тестирования.
  
  Ваше решение должно содержать только функции. 
  В решении не должно быть вызовов требуемых функций.


</details>

<details>
  <summary>Решение</summary>

  ```python
  import pandas as pd


  def cheque(price_list_of_groceries, **kwargs):
      dict_of_groceries = kwargs
      list_of_groceries_sorted = sorted(dict_of_groceries)
      list_of_total_for_grocery = []
      for grocery in list_of_groceries_sorted:
          list_of_total_for_grocery.append(dict_of_groceries[grocery] * price_list_of_groceries[grocery])
  
      return pd.DataFrame({"product": list_of_groceries_sorted,
                           "price": [price_list_of_groceries[data] for data in list_of_groceries_sorted],
                           "number": [dict_of_groceries[data] for data in list_of_groceries_sorted],
                           "cost": list_of_total_for_grocery})
  
  
  def discount(data_for_discount):
      list_of_discount = []
      for i in range(len(data_for_discount)):
          temp_number = data_for_discount.loc[i]["number"]
          temp_cost = data_for_discount.loc[i]["cost"]
          if temp_number > 2:
              temp_cost /= 2
          list_of_discount.append(temp_cost)
      return pd.DataFrame({"product": data_for_discount["product"],
                           "price": data_for_discount["price"],
                           "number": data_for_discount["number"],
                           "cost": list_of_discount})
  ```

</details>

## Длинные слова

<details>
  <summary>Условие</summary>
  Фильтрация данных — одна из первостепенных задач их анализа.

  Напишите функцию get_long, принимающую серию формата первой задачи и фильтрующую её по именованному параметру min_length (по умолчанию 5).
  
  ### Примечание
  Ваше решение должно содержать только функции. 
  В решении не должно быть вызовов требуемых функций.


</details>

<details>
  <summary>Решение</summary>

  ```python
  import pandas as pd


  def get_long(data_to_filter, min_length=5):
      return data_to_filter[data_to_filter >= min_length]
  ```

</details>

## Отчёт успеваемости

<details>
  <summary>Условие</summary>
  Во всех без исключения учебных заведениях ведутся журналы успеваемости. Это отличный пример данных, подлежащих обработке.

  Рассмотрим журнал летней олимпиадной школы, в которой основными предметами выступают математика, физика и информатика. Данные об успеваемости представлены DataFrame со столбцами:
  
  - name — имя;
  - maths — оценка по математике;
  - physics — оценка по физике;
  - computer science — оценка по информатике.
  
  Напишите функцию best, которая фильтрует всех «ударников» в журнале.
  
  ### Примечание
  Ваше решение должно содержать только функции. 
  В решении не должно быть вызовов требуемых функций.


</details>

<details>
  <summary>Решение</summary>

  ```python
  import pandas as pd


  def best(data_to_filter):
      need_index_list = []
      for i in range(len(data_to_filter)):
          count = 0
          need_to_count = 3
          for need_data in data_to_filter.loc[i][[data for data in data_to_filter.columns[1:]]]:
              if need_data >= 4:
                  count += 1
          if count == need_to_count:
              need_index_list.append(i)
      return data_to_filter.loc[[index for index in need_index_list]]
  ```

</details>

## Отчёт неуспеваемости

<details>
  <summary>Условие</summary>
  Продолжим обрабатывать DataFrame из прошлой задачи.

  Напишите функцию need_to_work_better, которая выбирает тех, у кого есть хотя бы одна двойка.
  
  ### Примечание
  Ваше решение должно содержать только функции. 
  В решении не должно быть вызовов требуемых функций.


</details>

<details>
  <summary>Решение</summary>

  ```python
  import pandas as pd


  def need_to_work_better(data_to_filter):
      need_index_list = []
      for i in range(len(data_to_filter)):
          for need_data in data_to_filter.loc[i][[data for data in data_to_filter.columns[1:]]]:
              if need_data == 2:
                  need_index_list.append(i)
                  break
      return data_to_filter.loc[[index for index in need_index_list]]
  ```

</details>

## Обновление журнала

<details>
  <summary>Условие</summary>
  Продолжим обрабатывать DataFrame из прошлых задач.

  Напишите функцию update, которая добавляет к данным столбец average, содержащий среднюю оценку ученика, а также сортирует данные по убыванию этого столбца, а при равенстве средних — по имени лексикографически.
  
  ### Примечание
  Ваше решение должно содержать только функции. 
  В решении не должно быть вызовов требуемых функций.


</details>

<details>
  <summary>Решение</summary>

  ```python
  import pandas as pd


  def update(data_to_filter):
      average = []
      for i in range(len(data_to_filter)):
          total = 0
          for need_data in data_to_filter.loc[i][[data for data in data_to_filter.columns[1:]]]:
              total += need_data
          average.append(total / 3)
      new_data = data_to_filter.copy()
      new_data["average"] = average
      return new_data.sort_values(by=['average', 'name'], ascending=[False, True])
  ```

</details>

## Бесконечный морской бой

<details>
  <summary>Условие</summary>
  Представьте себе поле морского боя, которое не имеет границ. Для простоты координаты выстрелов будем обозначать целыми координатами на плоскости.

  Бесконечное поле порождает большое количество данных, которые требуется проанализировать. Один из игроков для упрощения этой задачи просит вас написать программу, которая обрезает данные до ограниченного прямоугольника.
  
  ### Формат ввода
  В первой строке записано два числа — координаты верхнего левого угла. Во второй строке — правого нижнего.
  
  В файле data.csv находится датасет с координатами всех выстрелов противника.
  
  ### Формат вывода
  Часть датасета, ограниченная заданным прямоугольником.
  
  ### Примечание
  Скачать датасет из примера можно по этой [ссылке](https://yastatic.net/s3/ml-handbook/admin/data171_4fcbd1f963.csv?updated_at=2022-11-04T09:07:51.186Z).


</details>

<details>
  <summary>Решение</summary>

  ```python
  import pandas as pd

  left_upper = [int(data) for data in input().split(" ")]
  right_down = [int(data) for data in input().split(" ")]
  
  fired_shots = pd.read_csv("data.csv")
  fired_shots_fixed_x = fired_shots.loc[(fired_shots["x"] >= left_upper[0]) & (fired_shots["x"] <= right_down[0])]
  fired_shots_fixed = fired_shots_fixed_x.loc[(fired_shots_fixed_x["y"] <= left_upper[1]) & (fired_shots_fixed_x["y"] >= 
                                                                                             right_down[1])]
  print(fired_shots_fixed)
  ```

</details>

## Экстремум функции

<details>
  <summary>Условие</summary>
  Экстремум в математике — максимальное или минимальное значение функции на заданном множестве.

  Чаще всего математики для поиска экстремума функции прибегают к её дифференцированию. Однако мы можем обойти этот трудоёмкий процесс и схитрить.
  
  Напишите три функции:
  
  - values(func, start, end, step), строящую Series значений функции в точках диапазона и принимающую:
    - функцию одной переменной;
    - начало диапазона;
    - конец диапазона;
    - шаг вычисления;
  - min_extremum(data) возвращает точку, в которой был достигнут минимум на диапазоне;
  - max_extremum(data) возвращает точку, в который был достигнут максимум на диапазоне.
  ### Примечание
  Ваше решение должно содержать только функции. 
  В решении не должно быть вызовов требуемых функций.


</details>

<details>
  <summary>Решение</summary>

  ```python
  import pandas as pd
  import numpy as np
  
  
  def values(func, start, end, step):
      end += step
      need_2 = pd.Series(np.arange(start, end, step), index=np.arange(start, end, step))
      need_2[need_2] = func(need_2[need_2])
      return need_2
  
  
  def min_extremum(data):
      return data[data == min(data)].index[0]
  
  
  def max_extremum(data):
      return data[data == max(data)].index[0]
  ```

</details>
