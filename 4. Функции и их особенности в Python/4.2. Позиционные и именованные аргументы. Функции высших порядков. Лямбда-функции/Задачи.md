## Генератор списков

<details>
  <summary>Условие</summary>
  Большинство задач этой главы ориентировано на отработку навыков по разработке функций.

  Ваше решение будет использоваться как библиотека.
  
  Напишите функцию make_list, которая создаёт, заполняет и возвращает список заданного размера.
  
  Параметры функции:
  
  - length — требуемая длина списка;
  - value — значение элементов списка (по-умолчанию 0).
  
  ### Примечание
  Ваше решение должно содержать только функции. 
  В решении не должно быть вызовов требуемых функций.


</details>

<details>
  <summary>Решение</summary>

  ```python
  def make_list(length, value=0):
      list = []
      for i in range(length):
          list.append(value)
      return list
  ```

</details>

## Генератор матриц

<details>
  <summary>Условие</summary>
  Напишите функцию make_matrix, которая создаёт, заполняет и возвращает матрицу заданного размера.

  Параметры функции:
  
  - size — кортеж (ширина, высота) или одно число (для создания квадратной матрицы);
  - value — значение элементов списка (по-умолчанию 0).
  
  ### Примечание
  Ваше решение должно содержать только функции. 
  В решении не должно быть вызовов требуемых функций.


</details>

<details>
  <summary>Решение</summary>

  ```python
  def make_matrix(length, value=0):
      matrix = []
      if isinstance(length, int):
          for i in range(length):
              temp_matrix = []
              for j in range(length):
                  temp_matrix.append(value)
              matrix.append(temp_matrix)
      elif isinstance(length, tuple):
          for i in range(length[1]):
              temp_matrix = []
              for j in range(length[0]):
                  temp_matrix.append(value)
              matrix.append(temp_matrix)
      return matrix

  ```

</details>

## Функциональный нод 2.0

<details>
  <summary>Условие</summary>
  Напишите функцию gcd, которая вычисляет наибольший общий делитель последовательности чисел. 
  Параметрами функции выступают натуральные числа в произвольном количестве, но не менее одного.
  
  ### Примечание
  Ваше решение должно содержать только функции. 
  В решении не должно быть вызовов требуемых функций.


</details>

<details>
  <summary>Решение</summary>

  ```python
  def gcd_for_two(a, b):
      while a != 0 and b != 0:
          if a > b:
              a = a % b
          else:
              b = b % a
      return a + b
  
  
  def gcd(*numbers):
      numbers_for_gcd = list(numbers)
      while len(numbers_for_gcd) != 1:
          numbers_for_gcd.append(gcd_for_two(numbers_for_gcd.pop(), numbers_for_gcd.pop()))
      return numbers_for_gcd[0]
  ```

</details>

## Имя of the month 2.0

<details>
  <summary>Условие</summary>
  Разработайте функцию month, которая возвращает название заданного месяца с заглавной буквы. Функция должна принимать номер месяца и дополнительно обозначение языка (по умолчанию "ru").

  ### Примечание
  Ваше решение должно содержать только функции. 
  В решении не должно быть вызовов требуемых функций.


</details>

<details>
  <summary>Решение</summary>

  ```python
  def month(index, language='ru'):
      months = {
          'ru': ['Январь', 'Февраль', 'Март', 'Апрель', 'Май', 'Июнь', 'Июль',
                 'Август', 'Сентябрь', 'Октябрь', 'Ноябрь', 'Декабрь'],
          'en': ['January', 'February', 'March', 'April', 'May', 'June', 'July',
                 'August', 'September', 'October', 'November', 'December']
      }
  
      return months[language][index - 1]
  ```

</details>

## Подготовка данных

<details>
  <summary>Условие</summary>
  Напишите функцию to_string, которая формирует из последовательности данных строку. 
  Функция должна принимать:
  
  - неопределённое количество данных;
  - необязательный параметр sep (по умолчанию пробел);
  - необязательный параметр end (по умолчанию \n).
  
  ### Примечание
  Ваше решение должно содержать только функции. 
  В решении не должно быть вызовов требуемых функций.


</details>

<details>
  <summary>Решение</summary>

  ```python
  def to_string(*text, **kwargs):
      full_text = text
      sep = kwargs.get("sep", " ")
      end = kwargs.get("end", "\n")
      string_of_text = ""
      for words in full_text:
          string_of_text += str(words) + sep
      string_of_text = string_of_text.rstrip(sep) + end
      return string_of_text
  ```

</details>

## Кофейня

<details>
  <summary>Условие</summary>
  Руководство местной кофейни для программистов под названием Java-0x00 решило модернизировать систему заказа кофе.

  Для этого им требуется реализовать функцию order, которая принимает список предпочтений посетителя в порядке «убывания желания».
  
  Согласно положению, каждый напиток в кофейне строго определён рецептом:
  
  - Эспрессо готовится из: 1 порции кофейных зерен.
  - Капучино готовится из: 1 порции кофейных зерен и 3 порций молока.
  - Макиато готовится из: 2 порций кофейных зерен и 1 порции молока.
  - Кофе по-венски готовится из: 1 порции кофейных зерен и 2 порций взбитых сливок.
  - Латте Макиато готовится из: 1 порции кофейных зерен, 2 порций молока и 1 порции взбитых сливок.
  - Кон Панна готовится из: 1 порции кофейных зерен и 1 порции взбитых сливок.
  
  В глобальной переменной in_stock содержится словарь, описывающий ингредиенты в наличии. Ключи словаря: coffee, cream, milk.
  
  Функция должна вернуть:
  
  - название напитка, который будет приготовлен;
  - сообщение «К сожалению, не можем предложить Вам напиток», если ни одно из предпочтений не может быть приготовлено.
  
  Если заказ, может быть совершён, количество доступных ингредиентов должно соответствующим образом уменьшиться.
  
  ### Примечание
  В решении не должно быть вызовов требуемых функций.


</details>

<details>
  <summary>Решение</summary>

  ```python
  def order(*want_list):
      global in_stock
      coffee_dict = {
          "Эспрессо": {
              "coffee": 1
          },
          "Капучино": {
              "coffee": 1, "milk": 3
          },
          "Макиато": {
              "coffee": 2, "milk": 1
          },
          "Кофе по-венски": {
              "coffee": 1, "cream": 2
          },
          "Латте Макиато": {
              "coffee": 1, "milk": 2, "cream": 1
          },
          "Кон Панна": {
              "coffee": 1, "cream": 1
          }
      }
      cant_buy = "К сожалению, не можем предложить Вам напиток"
      for want in want_list:
          temp_len = len(coffee_dict[want])
          for ingredient in coffee_dict[want]:
              if in_stock[ingredient] >= coffee_dict[want][ingredient]:
                  temp_len -= 1
          if temp_len == 0:
              for ingredient in coffee_dict[want]:
                  in_stock[ingredient] -= coffee_dict[want][ingredient]
              return want
      return cant_buy
  ```

</details>

## В эфире рубрика «Эксперименты»

<details>
  <summary>Условие</summary>
  Лаборанты проводят эксперимент и запросили разработку системы обработки данных. Результатами эксперимента должны стать пары рациональных чисел.

  Для работы им требуются функции:
  
  - enter_results(first, second, ...) — добавление данных одного или нескольких результатов (гарантируется, что количество параметров будет чётным);
  - get_sum() — возвращает пару сумм результатов экспериментов;
  - get_average() — возвращает пару средних арифметических значений результатов экспериментов.
  
  Все вычисления производятся с точностью до сотых.
  
  ### Примечание
  В решении не должно быть вызовов требуемых функций.


</details>

<details>
  <summary>Решение</summary>

  ```python
  def enter_results(*results):
      global results_first
      global results_second
      for i in range(len(results)):
          if i % 2 == 0:
              results_first.append(results[i])
          else:
              results_second.append(results[i])
  
  
  def get_sum():
      global sum_first
      global sum_second
      sum_first, sum_second = 0, 0
      for number in results_first:
          sum_first += number
  
      for number in results_second:
          sum_second += number
      return round(sum_first, 2), round(sum_second, 2)
  
  
  def get_average():
      average_first = sum_first / len(results_first)
      average_second = sum_second / len(results_second)
      return round(average_first, 2), round(average_second, 2)
  
  
  results_first = list()
  results_second = list()
  ```

</details>

## Длинная сортировка

<details>
  <summary>Условие</summary>
  Напишите lambda выражение для сортировки списка слов сначала по длине, а затем по алфавиту без учёта регистра.

  ### Примечание
  В решении не должно быть ничего, кроме выражения.


</details>

<details>
  <summary>Решение</summary>

  ```python
  lambda line: (len(line), line.lower())
  ```

</details>

## Чётная фильтрация

<details>
  <summary>Условие</summary>
  Напишите lambda выражение для фильтрации чисел с чётной суммой цифр.

  ### Примечание
  В решении не должно быть ничего, кроме выражения.


</details>

<details>
  <summary>Решение</summary>

  ```python
  lambda x: sum([int(i) for i in str(x)]) % 2 == 0
  ```

</details>

## Ключевой секрет

<details>
  <summary>Условие</summary>
  Вася любит секреты и шифрование. Он часто пользуется шифром на основе замен и просит разработать вас функцию, которая позволит ему быстро шифровать сообщения.

  Напишите функцию secret_replace(text, **replaces), которая принимает:
  
  - текст требующий шифрования;
  - именованные аргументы — правила замен, представляющие собой кортежи из одного или нескольких значений.
  
  Функция должна вернуть зашифрованный текст.
  
  ### Примечание
  Ваше решение должно содержать только функции. 
  В решении не должно быть вызовов требуемых функций.
  
  Обратите внимание, что позиционный аргумент требуемой функции не должен иметь однобуквенного имени. Для понимания ошибки исследуйте следующих код:
  ```
  def func(a, **b):
      ...
  
  func(1, **{'a': 2})
  ```

</details>

<details>
  <summary>Решение</summary>

  ```python
  def secret_replace(text, **replaces):
      encrypted_text = ""
      for letter in replaces:
          replaces[letter] = list(replaces[letter])
      for letter in text:
          if replaces.get(letter, -1) != -1:
              encrypted_letter = replaces[letter].pop(-len(replaces[letter]))
              encrypted_text += encrypted_letter
              replaces[letter].append(encrypted_letter)
          else:
              encrypted_text += letter
      return encrypted_text


  ```

</details>
