
## Рекурсивный сумматор

<details>
  <summary>Условие</summary>
  Большинство задач этой главы ориентировано на отработку навыков по разработке рекурсивных функций.

  Ваше решение будет использоваться как библиотека.
  
  Напишите функцию recursive_sum, которая находит сумму всех позиционных аргументов.
  
  ### Примечание
  Ваше решение должно содержать только функции. 
  В решении не должно быть вызовов требуемых функций, за исключением рекурсивных. 
  Трассировка вызова рекурсивной функции в обработке ответа не учитывается и показана для примера.


</details>

<details>
  <summary>Решение</summary>

  ```python
  def recursive_sum(*numbers):
      if len(numbers) > 1:
          return recursive_sum(*numbers[:-1]) + numbers[-1]
      else:
          return numbers[0]
  ```

</details>

## Рекурсивный сумматор цифр

<details>
  <summary>Условие</summary>
  Рекурсия – отличный способ избавиться от циклов, особенно от while. Давайте вспомним одну из наших старых задач и модернизируем её.

  Напишите функцию recursive_digit_sum, которая находит сумму всех цифр натурального числа.
  
  ### Примечание
  Ваше решение должно содержать только функции. 
  В решении не должно быть вызовов требуемых функций, за исключением рекурсивных. 
  Трассировка вызова рекурсивной функции в обработке ответа не учитывается и показана для примера.


</details>

<details>
  <summary>Решение</summary>

  ```python
  def recursive_digit_sum(digit):
      if digit % 10 != 0:
          return recursive_digit_sum(digit // 10) + digit % 10
      elif digit % 10 == 0 and digit >= 10:
          return recursive_digit_sum(digit // 10)
      else:
          return digit
  ```

</details>

## Многочлен N-ой степени

<details>
  <summary>Условие</summary>
  Напишите функцию make_equation, которая по заданным коэффициентам строит строку, описывающую валидное с точки зрения Python выражение без использования оператора возведения в степень.

  Многочлен второй степени с коэффициентами a, b и c, например, можно записать в виде:((a)∗x+b)∗x+c
  
  ### Примечание
  Ваше решение должно содержать только функции. 
  В решении не должно быть вызовов требуемых функций, за исключением рекурсивных. 
  Трассировка вызова рекурсивной функции в обработке ответа не учитывается и показана для примера.


</details>

<details>
  <summary>Решение</summary>

  ```python
  def make_equation(*numbers):
      if len(numbers) == 1:
          return f'{numbers[0]}'
      else:
          return f'({make_equation(*numbers[:-1])}) * x + {numbers[-1]}'
  ```

</details>

## Декор результата

<details>
  <summary>Условие</summary>
  Напишите декоратор answer, который преобразует функцию, принимающую неограниченное число позиционных и именованных параметров и возвращает её результат с припиской "Результат функции: <значение>".

  ### Примечание
  Ваше решение должно содержать только функции. 
  В решении не должно быть вызовов требуемых функций.


</details>

<details>
  <summary>Решение</summary>

  ```python
  def answer(f):
      def decorated(*args, **kwargs):
          return f'Результат функции: {f(*args, **kwargs)}'
      return decorated
  ```

</details>

## Накопление результата

<details>
  <summary>Условие</summary>
  В некоторых случаях полезно накапливать результат, а затем получать его единым списком.

  Реализуйте декоратор result_accumulator, который модернизирует функцию с неопределенным количеством позиционных параметров следующим образом:
  
  - Добавляет именованный параметр method со значением по умолчанию accumulate;
  - При вызове функции с параметром method равным accumulate, результат сохраняется в очередь (для каждой функции в собственную), а функция ничего не возвращает;
  - При вызове функции с параметром method равным drop, возвращается все накопленные результаты, а очередь сбрасывается.
  
  ### Примечание
  Ваше решение должно содержать только функции. 
  В решении не должно быть вызовов требуемых функций.


</details>

<details>
  <summary>Решение</summary>

  ```python
  def result_accumulator(func):
      queue = []
  
      def wrapper(*args, method='accumulate', **kwargs):
          queue.append(func(*args, **kwargs))
          if method == 'drop':
              result = list(queue)
              queue.clear()
              return result
      return wrapper
  ```

</details>

## Сортировка слиянием

<details>
  <summary>Условие</summary>
  Мы уже реализовывали функцию merge, которая способна "слить" два отсортированных списка в один. 
  Чаще всего её применяют в рекурсивном алгоритме сортировки слиянием.
  
  Напишите рекурсивную функцию merge_sort, которая производит сортировку списка.
  
  ### Примечание
  Ваше решение должно содержать только функции. 
  В решении не должно быть вызовов требуемых функций, за исключением рекурсивных. 
  Трассировка вызова рекурсивной функции в обработке ответа не учитывается и показана для примера.


</details>

<details>
  <summary>Решение</summary>

  ```python
  def merge(first_tuple, second_tuple):
      merged_tuple = list()
      len_first = len(first_tuple)
      len_second = len(second_tuple)
      count_first = 0
      count_second = 0
      while (count_first < len_first) and (count_second < len_second):
          a = first_tuple[count_first]
          b = second_tuple[count_second]
          if min(a, b) == a:
              merged_tuple.append(a)
              count_first += 1
          elif min(a, b) == b:
              merged_tuple.append(b)
              count_second += 1
      if count_first == len_first:
          for i in range(count_second, len_second):
              merged_tuple.append(second_tuple[i])
      elif count_second == len_second:
          for i in range(count_first, len_first):
              merged_tuple.append(first_tuple[i])
      return merged_tuple
  
  
  def merge_sort(list_to_merge):
      len_of_list = len(list_to_merge)
      if len_of_list > 2:
          return merge(merge_sort(list_to_merge[len_of_list // 2:]), merge_sort(list_to_merge[:len_of_list // 2]))
      else:
          return merge(list_to_merge[:len_of_list // 2], list_to_merge[len_of_list // 2:])

  ```

</details>

## Однотипность не порок

<details>
  <summary>Условие</summary>
  Во многих задачах требуется контроль входных данных, в частности, несмотря на динамическую типизацию, их типов.

  Разработайте декоратор same_type, который производит проверку переменного количества позиционных параметров. В случае получения не одинаковых типов выводит сообщение "Обнаружены различные типы данных" и прерывает выполнение функции.
  
  ### Примечание
  Ваше решение должно содержать только функции. 
  В решении не должно быть вызовов требуемых функций.


</details>

<details>
  <summary>Решение</summary>

  ```python
  def same_type(func):
      def decorator(*args):
          type_of_first = type(args[0])
          for data in args[1:]:
              to_test_type = type(data)
              if to_test_type != type_of_first:
                  return print('Обнаружены различные типы данных')
              return func(*args)
      return decorator
  ```

</details>

## Генератор Фибоначчи

<details>
  <summary>Условие</summary>
  Числа Фибоначчи весьма интересная последовательность и используется в различных математических задачах. В ней каждый следующий элемент равен сумме двух предыдущих. Математики начинают эту последовательность с двух единиц, но мы же с вами программисты, поэтому привыкли вести счет с нуля.

  Напишите генератор fibonacci, который последовательно возвращает заданное количество чисел Фибоначчи по "правилам программистов".
  
  ### Примечание
  Ваше решение должно содержать только функции. 
  В решении не должно быть вызовов требуемых функций.


</details>

<details>
  <summary>Решение</summary>

  ```python
  def fibonacci(numbers):
      a, b = 0, 1
      for i in range(numbers):
          yield a
          a, b = b, a + b
  ```

</details>

## Циклический генератор

<details>
  <summary>Условие</summary>
  Напишите генератор cycle, который принимает список и работает аналогично итератору itertools.cycle.

  ### Примечание
  Ваше решение должно содержать только функции. 
  В решении не должно быть вызовов требуемых функций.


</details>

<details>
  <summary>Решение</summary>

  ```python
  def cycle(numbers):
      while True:
          for number in numbers:
              yield number
  ```

</details>

## "Выпрямление" списка

<details>
  <summary>Условие</summary>
  Весьма часто, данные, которые мы получаем из различных источников, не удовлетворяют нашим пожеланиям. Одна из частых проблем – излишняя вложенность списков.

  Напишите функцию make_linear, которая принимает список списков и возвращает его "выпрямленное" представление.
  
  ### Примечание
  Ваше решение должно содержать только функции. 
  В решении не должно быть вызовов требуемых функций, за исключением рекурсивных. 
  Трассировка вызова рекурсивной функции в обработке ответа не учитывается и показана для примера.


</details>

<details>
  <summary>Решение</summary>

  ```python
  def make_linear(list_to_linear):
      global fixed_list
      for data in list_to_linear:
          if isinstance(data, list):
              make_linear(data)
          else:
              fixed_list.append(data)
      return fixed_list
  
  fixed_list = list()
  ```

</details>
